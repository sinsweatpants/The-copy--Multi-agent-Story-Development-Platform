# السياق الهندسي الشامل: نظام Jules - منصة التطوير القصصي متعدد الوكلاء

## 📋 نظرة عامة على المشروع

### الهدف الرئيسي
تطوير تطبيق ويب إنتاجي متكامل يحول نظام "Jules" - المنظم الرئيسي لتطوير القصص - إلى منصة تفاعلية تدير 11 وكيلاً متخصصاً (AI Agents) لتحليل وتطوير المشاريع القصصية عبر واجهة مستخدم احترافية.

### الوصف الوظيفي
النظام يعمل كمنسق ذكي (Master Orchestrator) يدير جلسات تطوير قصصية متقدمة من خلال:
- إنشاء وإدارة 11 وكيلاً متخصصاً (كل وكيل يستخدم Gemini 2.5 Pro API)
- تنسيق عملية تطوير شاملة: تعريف المهمة → توليد الأفكار → المراجعة المستقلة → جلسة نقاش تنافسية → اتخاذ القرار النهائي
- تقديم واجهة مستخدم تفاعلية لإدارة العملية بالكامل

---

## 🏗️ البنية المعمارية (System Architecture)

### نموذج المعمارية: Microservices-Inspired Monolith
```
┌─────────────────────────────────────────────────────────┐
│                    CLIENT LAYER                         │
│  ┌──────────────────────────────────────────────────┐  │
│  │   React SPA (TypeScript + Vite)                  │  │
│  │   - State Management: Zustand/Redux Toolkit      │  │
│  │   - UI Framework: Tailwind CSS + shadcn/ui       │  │
│  │   - Real-time Updates: WebSocket Client          │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                          ↓ HTTPS/WSS
┌─────────────────────────────────────────────────────────┐
│                   API GATEWAY LAYER                     │
│  ┌──────────────────────────────────────────────────┐  │
│  │   FastAPI Gateway                                │  │
│  │   - JWT Authentication                           │  │
│  │   - Rate Limiting                                │  │
│  │   - Request Validation                           │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│               APPLICATION SERVICES LAYER                │
│  ┌────────────────┐  ┌────────────────┐  ┌──────────┐ │
│  │ Orchestration  │  │ Agent Manager  │  │ Session  │ │
│  │ Service        │  │ Service        │  │ Service  │ │
│  └────────────────┘  └────────────────┘  └──────────┘ │
│  ┌────────────────┐  ┌────────────────┐  ┌──────────┐ │
│  │ Idea Generator │  │ Review Engine  │  │ Decision │ │
│  │ Service        │  │ Service        │  │ Service  │ │
│  └────────────────┘  └────────────────┘  └──────────┘ │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                  INTEGRATION LAYER                      │
│  ┌──────────────────────────────────────────────────┐  │
│  │   Gemini API Integration Service                 │  │
│  │   - Connection Pool Management                   │  │
│  │   - Retry Logic with Exponential Backoff         │  │
│  │   - Response Streaming Handler                   │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                   DATA LAYER                            │
│  ┌─────────────┐  ┌─────────────┐  ┌────────────────┐ │
│  │ PostgreSQL  │  │   Redis     │  │  File Storage  │ │
│  │ (Primary DB)│  │   (Cache)   │  │  (Documents)   │ │
│  └─────────────┘  └─────────────┘  └────────────────┘ │
└─────────────────────────────────────────────────────────┘
```





---

## 🎯 المتطلبات الوظيفية التفصيلية

### المرحلة 1: تهيئة النظام وإنشاء الوكلاء

#### 1.1 إدارة مفتاح API
**الوظيفة**: `initiate_api_key_request()`
```python
# المدخلات
- user_id: UUID
- session_id: UUID

# المخرجات
- api_key_request_modal: UI Component
- validation_status: bool
- error_message: Optional[str]

# متطلبات التحقق
1. التحقق من صحة تنسيق مفتاح API
2. اختبار الاتصال بـ Gemini API
3. التحقق من الحصص المتاحة (Quota Check)
4. تشفير وتخزين المفتاح بشكل آمن
```

#### 1.2 إنشاء فريق الخبراء (11 وكيل)
**الوظيفة**: `create_agent_team(api_key: str, guide_files: Dict)`

```python
# تعريف الوكلاء
AGENTS_CONFIG = {
    "story_architect": {
        "name": "Story Architect Agent",
        "guide_file": "story_architect_agent_guide.md",
        "model": "gemini-2.5-pro",
        "temperature": 0.7,
        "max_tokens": 60000
    },
    "realism_critic": {
        "name": "Realism Critic Agent",
        "guide_file": "realism_critic__agent_guide.md",
        "model": "gemini-2.5-pro",
        "temperature": 0.6,
        "max_tokens": 40000
    },
    "strategic_analyst": {
        "name": "Strategic Analyst Agent",
        "guide_file": "strategic_analyst_agent_guide.md",
        "model": "gemini-2.5-pro",
        "temperature": 0.65,
        "max_tokens": 50000
    },
    "character_development": {
        "name": "Character Development Agent",
        "guide_file": "character_development_agent_guide.md",
        "model": "gemini-2.5-pro",
        "temperature": 0.75,
        "max_tokens": 50000
    },
    "character_expansion": {
        "name": "Character Expansion Agent",
        "guide_file": "character_expansion_agent_guide.md",
        "model": "gemini-2.5-pro",
        "temperature": 0.7,
        "max_tokens": 40000
    },
    "world_building": {
        "name": "World-Building Agent",
        "guide_file": "world_building_agent_guide.md",
        "model": "gemini-2.5-pro",
        "temperature": 0.7,
        "max_tokens": 50000
    },
    "dialogue_voice": {
        "name": "Dialogue & Voice Agent",
        "guide_file": "dialogue_voice_agent_guide.md",
        "model": "gemini-2.5-pro",
        "temperature": 0.8,
        "max_tokens": 40000
    },
    "theme": {
        "name": "Theme Agent",
        "guide_file": "theme_agent_guide.md",
        "model": "gemini-2.5-pro",
        "temperature": 0.65,
        "max_tokens": 40000
    },
    "genre_tone": {
        "name": "Genre & Tone Agent",
        "guide_file": "genre_tone_agent_guide.md",
        "model": "gemini-2.5-pro",
        "temperature": 0.7,
        "max_tokens": 40000
    },
    "pacing": {
        "name": "Pacing Agent",
        "guide_file": "pacing_agent_guide.md",
        "model": "gemini-2.5-pro",
        "temperature": 0.65,
        "max_tokens": 40000
    },
    "conflict_tension": {
        "name": "Conflict & Tension Agent",
        "guide_file": "conflict_tension_agent.md",  # يتم استنتاجه من البروتوكولات الأخرى
        "model": "gemini-2.5-pro",
        "temperature": 0.7,
        "max_tokens": 40000,
        "synthesized_from": ["story_architect", "character_development", "pacing"]
    }
}

# آلية الإنشاء
1. قراءة ملفات الأدلة (Guide Files)
2. إنشاء System Prompts لكل وكيل
3. تهيئة اتصالات Gemini API المنفصلة
4. إنشاء معرفات فريدة لكل وكيل
5. حفظ تكوينات الوكلاء في قاعدة البيانات
```

### المرحلة 2: آلية العمل (خطوة بخطوة)

#### 2.1 الخطوة 1: تحديد الهدف (Creative Brief)
```python
class CreativeBrief(BaseModel):
    session_id: UUID
    user_id: UUID
    core_idea: str  # الفكرة الأساسية
    main_characters: List[Character]
    genre: str
    target_audience: str
    themes: List[str]
    constraints: Optional[Dict]
    preferences: Optional[Dict]
    timestamp: datetime

# واجهة المستخدم
- نموذج متعدد الخطوات (Multi-step Form)
- حقول غنية بالنصوص (Rich Text Editors)
- معاينة فورية (Live Preview)
- حفظ تلقائي (Auto-save)
```

#### 2.2 الخطوة 2: توليد الأفكار المتنافسة
```python
async def generate_competing_ideas(
    brief: CreativeBrief,
    agents: Dict[str, Agent]
) -> Tuple[Idea, Idea]:
    """
    التعاون بين Story Architect و Character Development
    لتوليد فكرتين متكاملتين
    """
    
    # المرحلة 1: Story Architect يولد البنية القصصية
    story_structures = await agents["story_architect"].generate(
        prompt=create_story_prompt(brief),
        num_variations=2
    )
    
    # المرحلة 2: Character Development يطور الشخصيات لكل فكرة
    idea_1 = await agents["character_development"].enhance(
        story_structure=story_structures[0],
        brief=brief
    )
    
    idea_2 = await agents["character_development"].enhance(
        story_structure=story_structures[1],
        brief=brief
    )
    
    return (idea_1, idea_2)

# تنسيق الفكرة
class Idea(BaseModel):
    id: UUID
    title: str
    logline: str  # ملخص في سطر واحد
    synopsis: str  # ملخص مفصل (300-500 كلمة)
    three_act_structure: ThreeActBreakdown
    main_characters: List[CharacterProfile]
    key_scenes: List[SceneOutline]
    thematic_elements: List[str]
    unique_selling_points: List[str]
    generated_at: datetime
```

#### 2.3 الخطوة 3: المراجعة المستقلة
```python
async def conduct_independent_reviews(
    ideas: Tuple[Idea, Idea],
    agents: Dict[str, Agent],
    brief: CreativeBrief
) -> Dict[str, AgentReviews]:
    """
    كل وكيل يقيم كلتا الفكرتين بشكل مستقل
    """
    
    reviews = {}
    
    for agent_name, agent in agents.items():
        # تجهيز السياق المتخصص لكل وكيل
        specialized_prompt = create_review_prompt(
            agent_type=agent_name,
            idea_1=ideas[0],
            idea_2=ideas[1],
            brief=brief
        )
        
        # الحصول على المراجعة
        review = await agent.review(
            prompt=specialized_prompt,
            response_format=ReviewFormat
        )
        
        reviews[agent_name] = {
            "idea_1_review": review.idea_1_assessment,
            "idea_2_review": review.idea_2_assessment,
            "comparative_analysis": review.comparison
        }
    
    return reviews

# تنسيق المراجعة
class AgentReview(BaseModel):
    agent_name: str
    idea_id: UUID
    
    # الأقسام الثلاثة المطلوبة
    quality_score: float  # 0-10
    quality_analysis: str
    
    novelty_score: float  # 0-10
    novelty_analysis: str
    
    impact_score: float  # 0-10
    impact_analysis: str
    
    strengths: List[str]
    weaknesses: List[str]
    recommendations: List[str]
    
    overall_verdict: str
    timestamp: datetime
```

#### 2.4 الخطوة 4: جلسة النقاش التنافسية (The Tournament)
```python
class TournamentSession:
    """
    إدارة جلسة النقاش بين الوكلاء
    """
    
    def __init__(
        self,
        ideas: Tuple[Idea, Idea],
        reviews: Dict[str, AgentReviews],
        agents: Dict[str, Agent]
    ):
        self.ideas = ideas
        self.reviews = reviews
        self.agents = agents
        self.turns: List[TournamentTurn] = []
        self.current_turn = 0
        self.max_turns = 8
    
    async def conduct_tournament(self) -> TournamentResult:
        """
        تنفيذ جلسة النقاش الكاملة
        """
        
        # إعلان بداية الجلسة
        await self.announce_tournament_start()
        
        # تنفيذ الأدوار
        for turn_num in range(self.max_turns):
            turn = await self.execute_turn(turn_num)
            self.turns.append(turn)
            
            # بث مباشر للتحديثات
            await self.broadcast_turn_update(turn)
        
        # اختتام الجلسة
        result = await self.conclude_tournament()
        return result
    
    async def execute_turn(self, turn_num: int) -> TournamentTurn:
        """
        تنفيذ دور واحد من النقاش
        """
        
        # اختيار الوكلاء المشاركين في هذا الدور
        participating_agents = self.select_turn_participants(turn_num)
        
        arguments = []
        
        for agent_name in participating_agents:
            # بناء السياق الكامل للوكيل
            context = self.build_agent_context(
                agent_name=agent_name,
                previous_turns=self.turns,
                own_review=self.reviews[agent_name]
            )
            
            # الحصول على حجة الوكيل
            argument = await self.agents[agent_name].argue(
                context=context,
                format=ArgumentFormat
            )
            
            arguments.append(argument)
        
        return TournamentTurn(
            turn_number=turn_num,
            participants=participating_agents,
            arguments=arguments,
            timestamp=datetime.now()
        )

# هياكل البيانات
class Argument(BaseModel):
    agent_name: str
    supporting_idea: int  # 1 or 2
    
    # الحجج
    strengths_highlighted: List[str]
    weaknesses_criticized: List[str]
    comparative_points: List[str]
    
    # من منظور التخصص
    specialized_insight: str
    
    evidence_from_review: List[str]
    rebuttal_to_previous: Optional[str]
    
class TournamentTurn(BaseModel):
    turn_number: int
    participants: List[str]
    arguments: List[Argument]
    timestamp: datetime
```

#### 2.5 الخطوة 5: اتخاذ القرار النهائي
```python
async def make_final_decision(
    tournament: TournamentSession,
    orchestrator: MasterOrchestrator
) -> FinalDecision:
    """
    تحليل النقاش واتخاذ القرار النهائي
    """
    
    # تحليل الحجج
    analysis = analyze_tournament_arguments(tournament.turns)
    
    # طلب التصويت أو الإجماع
    voting_result = await conduct_agent_voting(
        agents=tournament.agents,
        tournament_summary=analysis
    )
    
    # تحديد الفكرة الفائزة
    winning_idea = determine_winner(voting_result)
    
    # إنشاء التقرير النهائي
    final_report = await orchestrator.generate_final_report(
        winning_idea=winning_idea,
        tournament_analysis=analysis,
        voting_details=voting_result,
        key_arguments=extract_key_arguments(tournament.turns)
    )
    
    return FinalDecision(
        winning_idea_id=winning_idea.id,
        decision_rationale=final_report,
        vote_breakdown=voting_result,
        confidence_score=calculate_confidence(voting_result),
        timestamp=datetime.now()
    )

class FinalDecision(BaseModel):
    session_id: UUID
    winning_idea_id: UUID
    losing_idea_id: UUID
    
    decision_rationale: str  # التقرير الشامل
    key_strengths: List[str]
    addressed_weaknesses: List[str]
    
    vote_breakdown: Dict[str, int]  # agent_name -> idea_voted_for
    unanimous: bool
    confidence_score: float  # 0-1
    
    implementation_recommendations: List[str]
    next_steps: List[str]
    
    timestamp: datetime
```

---

## 💻 المواصفات التقنية التفصيلية

### Backend Stack

#### Framework الرئيسي
```python
# FastAPI + Python 3.11+
"""
السبب:
- أداء عالي (Async/Await Native)
- تحقق تلقائي من البيانات (Pydantic)
- توثيق تلقائي (OpenAPI/Swagger)
- دعم WebSocket
"""

# بنية المشروع
backend/
├── app/
│   ├── __init__.py
│   ├── main.py                    # نقطة دخول التطبيق
│   ├── config.py                  # إعدادات التطبيق
│   │
│   ├── api/                       # API Endpoints
│   │   ├── __init__.py
│   │   ├── v1/
│   │   │   ├── __init__.py
│   │   │   ├── auth.py           # المصادقة
│   │   │   ├── sessions.py       # إدارة الجلسات
│   │   │   ├── agents.py         # إدارة الوكلاء
│   │   │   ├── ideas.py          # توليد ومراجعة الأفكار
│   │   │   ├── tournament.py     # جلسة النقاش
│   │   │   └── decisions.py      # القرارات النهائية
│   │   └── websocket.py          # WebSocket Endpoints
│   │
│   ├── core/                      # الوظائف الأساسية
│   │   ├── __init__.py
│   │   ├── security.py           # JWT, Encryption
│   │   ├── database.py           # Database Session
│   │   ├── cache.py              # Redis Integration
│   │   └── config.py             # Configuration Management
│   │
│   ├── services/                  # منطق الأعمال
│   │   ├── __init__.py
│   │   ├── orchestrator.py       # المنظم الرئيسي
│   │   ├── agent_manager.py      # إدارة الوكلاء
│   │   ├── session_service.py    # إدارة الجلسات
│   │   ├── idea_generator.py     # توليد الأفكار
│   │   ├── review_engine.py      # محرك المراجعة
│   │   ├── tournament_manager.py # إدارة النقاش
│   │   └── decision_maker.py     # اتخاذ القرار
│   │
│   ├── integrations/              # التكاملات الخارجية
│   │   ├── __init__.py
│   │   ├── gemini/
│   │   │   ├── __init__.py
│   │   │   ├── client.py         # Gemini API Client
│   │   │   ├── prompts.py        # Prompt Engineering
│   │   │   ├── streaming.py      # Response Streaming
│   │   │   └── retry.py          # Retry Logic
│   │   └── storage/
│   │       ├── __init__.py
│   │       └── file_storage.py   # File Upload/Download
│   │
│   ├── models/                    # نماذج قاعدة البيانات
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── session.py
│   │   ├── agent.py
│   │   ├── idea.py
│   │   ├── review.py
│   │   ├── tournament.py
│   │   └── decision.py
│   │
│   ├── schemas/                   # Pydantic Schemas
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── session.py
│   │   ├── agent.py
│   │   ├── idea.py
│   │   ├── review.py
│   │   ├── tournament.py
│   │   └── decision.py
│   │
│   ├── utils/                     # أدوات مساعدة
│   │   ├── __init__.py
│   │   ├── validators.py         # Data Validation
│   │   ├── formatters.py         # Data Formatting
│   │   ├── logger.py             # Logging Configuration
│   │   └── exceptions.py         # Custom Exceptions
│   │
│   └── tests/                     # الاختبارات
│       ├── __init__.py
│       ├── unit/
│       ├── integration/
│       └── e2e/
│
├── alembic/                       # Database Migrations
│   ├── versions/
│   └── env.py
│
├── requirements.txt               # Python Dependencies
├── requirements-dev.txt           # Dev Dependencies
├── docker-compose.yml            # Docker Configuration
├── Dockerfile                    # Docker Image
└── .env.example                  # Environment Variables Template
```

#### المكتبات الأساسية
```txt
# requirements.txt

# Web Framework
fastapi==0.109.0
uvicorn[standard]==0.27.0
python-multipart==0.0.6

# Database
sqlalchemy==2.0.25
asyncpg==0.29.0
alembic==1.13.1

# Caching
redis==5.0.1
hiredis==2.3.2

# Authentication & Security
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6

# Google Gemini API
google-generativeai==0.3.2
google-auth==2.27.0

# Data Validation
pydantic==2.5.3
pydantic-settings==2.1.0
email-validator==2.1.0

# Utilities
python-dotenv==1.0.0
httpx==0.26.0
aiofiles==23.2.1
python-slugify==8.0.1

# Monitoring & Logging
structlog==24.1.0
sentry-sdk[fastapi]==1.40.0

# Testing
pytest==7.4.4
pytest-asyncio==0.23.3
pytest-cov==4.1.0
httpx==0.26.0

# Code Quality
black==24.1.1
ruff==0.1.14
mypy==1.8.0
```

### Frontend Stack

#### Framework الرئيسي
```json
{
  "name": "jules-frontend",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.21.3",
    
    // State Management
    "zustand": "^4.4.7",
    "@tanstack/react-query": "^5.17.19",
    
    // UI Framework
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-toast": "^1.1.5",
    "@radix-ui/react-progress": "^1.0.3",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.2.0",
    
    // Forms
    "react-hook-form": "^7.49.3",
    "zod": "^3.22.4",
    "@hookform/resolvers": "^3.3.4",
    
    // Rich Text Editor
    "@tiptap/react": "^2.1.16",
    "@tiptap/starter-kit": "^2.1.16",
    
    // Real-time
    "socket.io-client": "^4.6.1",
    
    // Markdown
    "react-markdown": "^9.0.1",
    "remark-gfm": "^4.0.0",
    
    // Icons
    "lucide-react": "^0.309.0",
    
    // Animations
    "framer-motion": "^10.18.0",
    
    // Utilities
    "axios": "^1.6.5",
    "date-fns": "^3.2.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.48",
    "@types/react-dom": "^18.2.18",
    "@typescript-eslint/eslint-plugin": "^6.19.0",
    "@typescript-eslint/parser": "^6.19.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.17",
    "eslint": "^8.56.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.33",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.3.3",
    "vite": "^5.0.11"
  }
}
```

#### بنية المشروع
```
frontend/
├── public/
│   ├── favicon.ico
│   └── robots.txt
│
├── src/
│   ├── main.tsx                   # نقطة الدخول
│   ├── App.tsx                    # المكون الرئيسي
│   ├── index.css                  # الأنماط العامة
│   │
│   ├── components/                # المكونات القابلة لإعادة الاستخدام
│   │   ├── ui/                    # مكونات UI الأساسية
│   │   │   ├── button.tsx
│   │   │   ├── input.tsx
│   │   │   ├── dialog.tsx
│   │   │   ├── tabs.tsx
│   │   │   ├── progress.tsx
│   │   │   └── ...
│   │   │
│   │   ├── layout/                # مكونات التخطيط
│   │   │   ├── Header.tsx
│   │   │   ├── Sidebar.tsx
│   │   │   ├── MainLayout.tsx
│   │   │   └── Footer.tsx
│   │   │
│   │   ├── forms/                 # نماذج مخصصة
│   │   │   ├── CreativeBriefForm.tsx
│   │   │   ├── ApiKeyForm.tsx
│   │   │   └── ...
│   │   │
│   │   └── features/              # مكونات مرتبطة بميزات محددة
│   │       ├── AgentCard.tsx
│   │       ├── IdeaDisplay.tsx
│   │       ├── ReviewPanel.tsx
│   │       ├── TournamentView.tsx
│   │       └── DecisionReport.tsx
│   │
│   ├── pages/                     # صفحات التطبيق
│   │   ├── Home.tsx
│   │   ├── Dashboard.tsx
│   │   ├── NewSession.tsx
│   │   ├── SessionDetail.tsx
│   │   ├── IdeaGeneration.tsx
│   │   ├── ReviewPhase.tsx
│   │   ├── Tournament.tsx
│   │   ├── FinalDecision.tsx
│   │   └── History.tsx
│   │
│   ├── store/                     # إدارة الحالة (Zustand)
│   │   ├── authStore.ts
│   │   ├── sessionStore.ts
│   │   ├── agentStore.ts
│   │   ├── ideaStore.ts
│   │   ├── tournamentStore.ts
│   │   └── index.ts
│   │
│   ├── hooks/                     # Custom React Hooks
│   │   ├── useAuth.ts
│   │   ├── useWebSocket.ts
│   │   ├── useAgents.ts
│   │   ├── useSession.ts
│   │   └── useTournament.ts
│   │
│   ├── services/                  # API Services
│   │   ├── api.ts                 # Axios Instance
│   │   ├── auth.service.ts
│   │   ├── session.service.ts
│   │   ├── agent.service.ts
│   │   ├── idea.service.ts
│   │   └── tournament.service.ts
│   │
│   ├── types/                     # TypeScript Types
│   │   ├── api.types.ts
│   │   ├── agent.types.ts
│   │   ├── session.types.ts
│   │   ├── idea.types.ts
│   │   └── tournament.types.ts
│   │
│   ├── utils/                     # أدوات مساعدة
│   │   ├── validators.ts
│   │   ├── formatters.ts
│   │   ├── constants.ts
│   │   └── helpers.ts
│   │
│   └── lib/                       # مكتبات مساعدة
│       ├── cn.ts                  # Class Name Utility
│       └── websocket.ts           # WebSocket Client
│
├── .env.example                   # متغيرات البيئة
├── .eslintrc.cjs                  # ESLint Config
├── tsconfig.json                  # TypeScript Config
├── tailwind.config.js             # Tailwind Config
├── vite.config.ts                 # Vite Config
└── package.json
```

---

## 🗄️ تصميم قاعدة البيانات (PostgreSQL)

### مخطط قاعدة البيانات
```sql
-- ============================================
-- جدول المستخدمين
-- ============================================
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    hashed_password VARCHAR(255) NOT NULL,
    full_name VARCHAR(255),
    is_active BOOLEAN DEFAULT TRUE,
    is_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP WITH TIME ZONE,
    
    -- Indexes
    CONSTRAINT email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$')
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);

-- ============================================
-- جدول مفاتيح API
-- ============================================
CREATE TABLE api_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    encrypted_key TEXT NOT NULL,
    key_name VARCHAR(100),
    is_active BOOLEAN DEFAULT TRUE,
    quota_limit INTEGER,
    quota_used INTEGER DEFAULT 0,
    last_used_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_api_keys_user_id ON api_keys(user_id);
CREATE INDEX idx_api_keys_active ON api_keys(is_active) WHERE is_active = TRUE;

-- ============================================
-- جدول الجلسات
-- ============================================
CREATE TABLE sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    api_key_id UUID NOT NULL REFERENCES api_keys(id),
    
    -- مراحل الجلسة
    status VARCHAR(50) NOT NULL DEFAULT 'initialized',
    current_phase VARCHAR(50) NOT NULL DEFAULT 'brief',
    
    -- بيانات الجلسة
    session_data JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- التوقيتات
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP WITH TIME ZONE,
    
    -- Metadata
    metadata JSONB DEFAULT '{}'::jsonb,
    
    CONSTRAINT valid_status CHECK (status IN (
        'initialized', 'brief_submitted', 'ideas_generating', 
        'ideas_generated', 'reviewing', 'tournament_active', 
        'decision_made', 'completed', 'failed'
    )),
    CONSTRAINT valid_phase CHECK (current_phase IN (
        'brief', 'idea_generation', 'independent_review', 
        'tournament', 'final_decision'
    ))
);

CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_status ON sessions(status);
CREATE INDEX idx_sessions_created_at ON sessions(created_at DESC);

-- ============================================
-- جدول الوكلاء
-- ============================================
CREATE TABLE agents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
    
    -- معلومات الوكيل
    agent_type VARCHAR(50) NOT NULL,
    agent_name VARCHAR(100) NOT NULL,
    guide_content TEXT,
    
    -- تكوين Gemini
    model_name VARCHAR(50) DEFAULT 'gemini-2.5-pro',
    temperature DECIMAL(3,2) DEFAULT 0.70,
    max_tokens INTEGER DEFAULT 40000,
    
    -- الحالة
    status VARCHAR(50) DEFAULT 'initialized',
    is_active BOOLEAN DEFAULT TRUE,
    
    -- Metadata
    config JSONB DEFAULT '{}'::jsonb,
    statistics JSONB DEFAULT '{}'::jsonb,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT valid_agent_type CHECK (agent_type IN (
        'story_architect', 'realism_critic', 'strategic_analyst',
        'character_development', 'character_expansion', 'world_building',
        'dialogue_voice', 'theme', 'genre_tone', 'pacing', 'conflict_tension'
    ))
);

CREATE INDEX idx_agents_session_id ON agents(session_id);
CREATE INDEX idx_agents_type ON agents(agent_type);

-- ============================================
-- جدول الموجهات الإبداعية (Creative Briefs)
-- ============================================
CREATE TABLE creative_briefs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID UNIQUE NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
    
    -- المحتوى الأساسي
    core_idea TEXT NOT NULL,
    genre VARCHAR(100) NOT NULL,
    target_audience TEXT,
    
    -- البيانات المنظمة
    main_characters JSONB DEFAULT '[]'::jsonb,
    themes JSONB DEFAULT '[]'::jsonb,
    constraints JSONB DEFAULT '{}'::jsonb,
    preferences JSONB DEFAULT '{}'::jsonb,
    
    -- التوقيتات
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT core_idea_min_length CHECK (char_length(core_idea) >= 50)
);

CREATE INDEX idx_creative_briefs_session_id ON creative_briefs(session_id);

-- ============================================
-- جدول الأفكار
-- ============================================
CREATE TABLE ideas (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
    idea_number INTEGER NOT NULL CHECK (idea_number IN (1, 2)),
    
    -- المحتوى
    title VARCHAR(255) NOT NULL,
    logline TEXT NOT NULL,
    synopsis TEXT NOT NULL,
    
    -- البنية القصصية
    three_act_structure JSONB NOT NULL,
    main_characters JSONB NOT NULL DEFAULT '[]'::jsonb,
    key_scenes JSONB NOT NULL DEFAULT '[]'::jsonb,
    thematic_elements JSONB DEFAULT '[]'::jsonb,
    unique_selling_points JSONB DEFAULT '[]'::jsonb,
    
    -- البيانات الوصفية
    generated_by_agents JSONB NOT NULL,
    generation_metadata JSONB DEFAULT '{}'::jsonb,
    
    -- التوقيتات
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT unique_idea_per_session UNIQUE (session_id, idea_number)
);

CREATE INDEX idx_ideas_session_id ON ideas(session_id);

-- ============================================
-- جدول المراجعات
-- ============================================
CREATE TABLE reviews (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
    agent_id UUID NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
    idea_id UUID NOT NULL REFERENCES ideas(id) ON DELETE CASCADE,
    
    -- الدرجات (0-10)
    quality_score DECIMAL(3,1) NOT NULL CHECK (quality_score >= 0 AND quality_score <= 10),
    novelty_score DECIMAL(3,1) NOT NULL CHECK (novelty_score >= 0 AND novelty_score <= 10),
    impact_score DECIMAL(3,1) NOT NULL CHECK (impact_score >= 0 AND impact_score <= 10),
    
    -- التحليلات النصية
    quality_analysis TEXT NOT NULL,
    novelty_analysis TEXT NOT NULL,
    impact_analysis TEXT NOT NULL,
    
    -- البيانات المنظمة
    strengths JSONB DEFAULT '[]'::jsonb,
    weaknesses JSONB DEFAULT '[]'::jsonb,
    recommendations JSONB DEFAULT '[]'::jsonb,
    
    overall_verdict TEXT NOT NULL,
    
    -- Metadata
    review_metadata JSONB DEFAULT '{}'::jsonb,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT unique_agent_idea_review UNIQUE (agent_id, idea_id)
);

CREATE INDEX idx_reviews_session_id ON reviews(session_id);
CREATE INDEX idx_reviews_agent_id ON reviews(agent_id);
CREATE INDEX idx_reviews_idea_id ON reviews(idea_id);

-- ============================================
-- جدول البطولات (Tournaments)
-- ============================================
CREATE TABLE tournaments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID UNIQUE NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
    
    -- الحالة
    status VARCHAR(50) NOT NULL DEFAULT 'active',
    current_turn INTEGER DEFAULT 0,
    max_turns INTEGER DEFAULT 8,
    
    -- البيانات
    tournament_data JSONB DEFAULT '{}'::jsonb,
    
    -- التوقيتات
    started_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    ended_at TIMESTAMP WITH TIME ZONE,
    
    CONSTRAINT valid_tournament_status CHECK (status IN ('active', 'completed', 'cancelled'))
);

CREATE INDEX idx_tournaments_session_id ON tournaments(session_id);

-- ============================================
-- جدول أدوار البطولة
-- ============================================
CREATE TABLE tournament_turns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tournament_id UUID NOT NULL REFERENCES tournaments(id) ON DELETE CASCADE,
    turn_number INTEGER NOT NULL,
    
    -- المشاركون
    participating_agents JSONB NOT NULL,
    
    -- الحجج
    arguments JSONB NOT NULL DEFAULT '[]'::jsonb,
    
    -- Metadata
    turn_metadata JSONB DEFAULT '{}'::jsonb,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT unique_tournament_turn UNIQUE (tournament_id, turn_number),
    CONSTRAINT positive_turn_number CHECK (turn_number >= 0)
);

CREATE INDEX idx_tournament_turns_tournament_id ON tournament_turns(tournament_id);
CREATE INDEX idx_tournament_turns_number ON tournament_turns(turn_number);

-- ============================================
-- جدول القرارات النهائية
-- ============================================
CREATE TABLE final_decisions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID UNIQUE NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
    tournament_id UUID NOT NULL REFERENCES tournaments(id),
    
    -- الفكرة الفائزة
    winning_idea_id UUID NOT NULL REFERENCES ideas(id),
    losing_idea_id UUID NOT NULL REFERENCES ideas(id),
    
    -- التقرير
    decision_rationale TEXT NOT NULL,
    key_strengths JSONB DEFAULT '[]'::jsonb,
    addressed_weaknesses JSONB DEFAULT '[]'::jsonb,
    
    -- التصويت
    vote_breakdown JSONB NOT NULL,
    unanimous BOOLEAN NOT NULL,
    confidence_score DECIMAL(3,2) CHECK (confidence_score >= 0 AND confidence_score <= 1),
    
    -- التوصيات
    implementation_recommendations JSONB DEFAULT '[]'::jsonb,
    next_steps JSONB DEFAULT '[]'::jsonb,
    
    -- Metadata
    decision_metadata JSONB DEFAULT '{}'::jsonb,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT different_ideas CHECK (winning_idea_id != losing_idea_id)
);

CREATE INDEX idx_final_decisions_session_id ON final_decisions(session_id);
CREATE INDEX idx_final_decisions_winning_idea ON final_decisions(winning_idea_id);

-- ============================================
-- جدول سجل النشاطات
-- ============================================
CREATE TABLE activity_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID REFERENCES sessions(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    
    -- النشاط
    activity_type VARCHAR(100) NOT NULL,
    activity_description TEXT,
    
    -- البيانات
    activity_data JSONB DEFAULT '{}'::jsonb,
    
    -- Metadata
    ip_address INET,
    user_agent TEXT,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_activity_logs_session_id ON activity_logs(session_id);
CREATE INDEX idx_activity_logs_user_id ON activity_logs(user_id);
CREATE INDEX idx_activity_logs_type ON activity_logs(activity_type);
CREATE INDEX idx_activity_logs_created_at ON activity_logs(created_at DESC);

-- ============================================
-- Triggers للتحديث التلقائي
-- ============================================

-- تحديث updated_at تلقائياً
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at 
    BEFORE UPDATE ON users 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_sessions_updated_at 
    BEFORE UPDATE ON sessions 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_creative_briefs_updated_at 
    BEFORE UPDATE ON creative_briefs 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
```

---

## 🔒 متطلبات الأمان

### 1. المصادقة والترخيص
```python
# JWT Implementation
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext

class SecurityService:
    """
    خدمة الأمان الشاملة
    """
    
    def __init__(self):
        self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        self.SECRET_KEY = os.getenv("JWT_SECRET_KEY")
        self.ALGORITHM = "HS256"
        self.ACCESS_TOKEN_EXPIRE_MINUTES = 30
        self.REFRESH_TOKEN_EXPIRE_DAYS = 7
    
    def hash_password(self, password: str) -> str:
        """تشفير كلمة المرور"""
        return self.pwd_context.hash(password)
    
    def verify_password(self, plain: str, hashed: str) -> bool:
        """التحقق من كلمة المرور"""
        return self.pwd_context.verify(plain, hashed)
    
    def create_access_token(
        self, 
        data: dict, 
        expires_delta: Optional[timedelta] = None
    ) -> str:
        """إنشاء Access Token"""
        to_encode = data.copy()
        
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(
                minutes=self.ACCESS_TOKEN_EXPIRE_MINUTES
            )
        
        to_encode.update({"exp": expire, "type": "access"})
        return jwt.encode(to_encode, self.SECRET_KEY, algorithm=self.ALGORITHM)
    
    def create_refresh_token(self, data: dict) -> str:
        """إنشاء Refresh Token"""
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(days=self.REFRESH_TOKEN_EXPIRE_DAYS)
        to_encode.update({"exp": expire, "type": "refresh"})
        return jwt.encode(to_encode, self.SECRET_KEY, algorithm=self.ALGORITHM)
```

### 2. تشفير مفاتيح API
```python
from cryptography.fernet import Fernet

class APIKeyEncryption:
    """
    تشفير وفك تشفير مفاتيح API
    """
    
    def __init__(self):
        self.encryption_key = os.getenv("ENCRYPTION_KEY").encode()
        self.cipher_suite = Fernet(self.encryption_key)
    
    def encrypt_api_key(self, api_key: str) -> str:
        """تشفير مفتاح API"""
        encrypted = self.cipher_suite.encrypt(api_key.encode())
        return encrypted.decode()
    
    def decrypt_api_key(self, encrypted_key: str) -> str:
        """فك تشفير مفتاح API"""
        decrypted = self.cipher_suite.decrypt(encrypted_key.encode())
        return decrypted.decode()
```

### 3. Rate Limiting
```python
from fastapi import HTTPException
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

# تطبيق على Endpoints
@app.post("/api/v1/sessions")
@limiter.limit("10/minute")  # 10 طلبات في الدقيقة
async def create_session(request: Request, ...):
    pass

@app.post("/api/v1/ideas/generate")
@limiter.limit("5/hour")  # 5 طلبات في الساعة (لتوليد الأفكار)
async def generate_ideas(request: Request, ...):
    pass
```

### 4. Input Validation
```python
from pydantic import BaseModel, validator, Field

class CreativeBriefInput(BaseModel):
    core_idea: str = Field(..., min_length=50, max_length=5000)
    genre: str = Field(..., min_length=3, max_length=100)
    target_audience: Optional[str] = Field(None, max_length=1000)
    
    @validator('core_idea')
    def validate_core_idea(cls, v):
        # منع HTML/Script Injection
        if '<script' in v.lower() or '<iframe' in v.lower():
            raise ValueError('HTML tags are not allowed')
        return v
    
    @validator('genre')
    def validate_genre(cls, v):
        allowed_genres = [
            'drama', 'thriller', 'horror', 'romance', 
            'comedy', 'action', 'sci-fi', 'fantasy'
        ]
        if v.lower() not in allowed_genres:
            raise ValueError(f'Genre must be one of: {allowed_genres}')
        return v
```

---

## ⚡ متطلبات الأداء

### 1. Caching Strategy
```python
import redis.asyncio as redis
from functools import wraps
import json

class CacheService:
    """
    خدمة التخزين المؤقت
    """
    
    def __init__(self):
        self.redis_client = redis.from_url(
            os.getenv("REDIS_URL"),
            encoding="utf-8",
            decode_responses=True
        )
    
    async def get(self, key: str):
        """استرجاع من الذاكرة المؤقتة"""
        value = await self.redis_client.get(key)
        return json.loads(value) if value else None
    
    async def set(
        self, 
        key: str, 
        value: any, 
        expire: int = 3600
    ):
        """حفظ في الذاكرة المؤقتة"""
        await self.redis_client.set(
            key, 
            json.dumps(value), 
            ex=expire
        )
    
    async def delete(self, key: str):
        """حذف من الذاكرة المؤقتة"""
        await self.redis_client.delete(key)

# Decorator للـ Caching
def cached(expire: int = 3600):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            cache = CacheService()
            
            # إنشاء مفتاح فريد
            cache_key = f"{func.__name__}:{str(args)}:{str(kwargs)}"
            
            # محاولة الاسترجاع من Cache
            cached_result = await cache.get(cache_key)
            if cached_result:
                return cached_result
            
            # تنفيذ الدالة
            result = await func(*args, **kwargs)
            
            # حفظ في Cache
            await cache.set(cache_key, result, expire)
            
            return result
        return wrapper
    return decorator
```

### 2. Database Connection Pooling
```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

engine = create_async_engine(
    DATABASE_URL,
    echo=False,
    pool_size=20,  # عدد الاتصالات الدائمة
    max_overflow=10,  # اتصالات إضافية عند الحاجة
    pool_pre_ping=True,  # التحقق من الاتصال قبل الاستخدام
    pool_recycle=3600,  # إعادة تدوير الاتصالات كل ساعة
)

AsyncSessionLocal = sessionmaker(
    engine, 
    class_=AsyncSession, 
    expire_on_commit=False
)
```

### 3. Gemini API Optimization
```python
class GeminiClientPool:
    """
    إدارة مجموعة من اتصالات Gemini API
    """
    
    def __init__(self, api_key: str, pool_size: int = 5):
        self.api_key = api_key
        self.pool_size = pool_size
        self.clients = []
        self.semaphore = asyncio.Semaphore(pool_size)
    
    async def get_client(self):
        """الحصول على client من المجموعة"""
        async with self.semaphore:
            if not self.clients:
                client = genai.GenerativeModel('gemini-2.5-pro')
                return client
            return self.clients.pop()
    
    async def return_client(self, client):
        """إرجاع client إلى المجموعة"""
        self.clients.append(client)
```

---

## 🔄 WebSocket Implementation

### Backend WebSocket Handler
```python
from fastapi import WebSocket, WebSocketDisconnect
from typing import Dict, Set

class ConnectionManager:
    """
    إدارة اتصالات WebSocket
    """
    
    def __init__(self):
        self.active_connections: Dict[str, Set[WebSocket]] = {}
    
    async def connect(self, session_id: str, websocket: WebSocket):
        """إضافة اتصال جديد"""
        await websocket.accept()
        
        if session_id not in self.active_connections:
            self.active_connections[session_id] = set()
        
        self.active_connections[session_id].add(websocket)
    
    def disconnect(self, session_id: str, websocket: WebSocket):
        """إزالة اتصال"""
        if session_id in self.active_connections:
            self.active_connections[session_id].discard(websocket)
    
    async def broadcast_to_session(
        self, 
        session_id: str, 
        message: dict
    ):
        """بث رسالة لجميع الاتصالات في جلسة معينة"""
        if session_id in self.active_connections:
            for connection in self.active_connections[session_id]:
                try:
                    await connection.send_json(message)
                except:
                    pass

manager = ConnectionManager()

@app.websocket("/ws/{session_id}")
async def websocket_endpoint(
    websocket: WebSocket, 
    session_id: str,
    current_user: User = Depends(get_current_user_ws)
):
    await manager.connect(session_id, websocket)
    
    try:
        while True:
            # استقبال الرسائل (اختياري)
            data = await websocket.receive_json()
            
            # معالجة الرسالة إذا لزم الأمر
            
    except WebSocketDisconnect:
        manager.disconnect(session_id, websocket)
```

### Frontend WebSocket Client
```typescript
// hooks/useWebSocket.ts
import { useEffect, useRef, useState } from 'react';
import { useAuthStore } from '@/store/authStore';

export interface WebSocketMessage {
  type: string;
  payload: any;
  timestamp: string;
}

export function useWebSocket(sessionId: string) {
  const [isConnected, setIsConnected] = useState(false);
  const [messages, setMessages] = useState<WebSocketMessage[]>([]);
  const ws = useRef<WebSocket | null>(null);
  const { token } = useAuthStore();
  
  useEffect(() => {
    if (!sessionId || !token) return;
    
    // إنشاء الاتصال
    const wsUrl = `${import.meta.env.VITE_WS_URL}/ws/${sessionId}?token=${token}`;
    ws.current = new WebSocket(wsUrl);
    
    ws.current.onopen = () => {
      console.log('WebSocket Connected');
      setIsConnected(true);
    };
    
    ws.current.onmessage = (event) => {
      const message: WebSocketMessage = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
      
      // معالجة أنواع الرسائل المختلفة
      handleMessage(message);
    };
    
    ws.current.onerror = (error) => {
      console.error('WebSocket Error:', error);
    };
    
    ws.current.onclose = () => {
      console.log('WebSocket Disconnected');
      setIsConnected(false);
    };
    
    // تنظيف
    return () => {
      ws.current?.close();
    };
  }, [sessionId, token]);
  
  const handleMessage = (message: WebSocketMessage) => {
    switch (message.type) {
      case 'phase_update':
        // تحديث المرحلة الحالية
        break;
      case 'idea_generated':
        // فكرة جديدة تم توليدها
        break;
      case 'review_completed':
        // مراجعة اكتملت
        break;
      case 'tournament_turn':
        // دور جديد في البطولة
        break;
      case 'decision_made':
        // قرار نهائي
        break;
    }
  };
  
  return {
    isConnected,
    messages,
    ws: ws.current
  };
}
```

---

## 📦 متطلبات النشر (Deployment)

### Docker Configuration
```dockerfile
# backend/Dockerfile

# Build Stage
FROM python:3.11-slim as builder

WORKDIR /app

# تثبيت المتطلبات
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

# Production Stage
FROM python:3.11-slim

WORKDIR /app

# نسخ المتطلبات المثبتة
COPY --from=builder /root/.local /root/.local

# إضافة المسار
ENV PATH=/root/.local/bin:$PATH

# نسخ الكود
COPY . .

# المنفذ
EXPOSE 8000

# الأمر
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```dockerfile
# frontend/Dockerfile

# Build Stage
FROM node:20-alpine as builder

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

# Production Stage
FROM nginx:alpine

# نسخ الملفات المبنية
COPY --from=builder /app/dist /usr/share/nginx/html

# تكوين Nginx
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

### Docker Compose
```yaml
version: '3.8'

services:
  # PostgreSQL Database
  postgres:
    image: postgres:16-alpine
    container_name: jules-postgres
    environment:
      POSTGRES_DB: jules_db
      POSTGRES_USER: jules_user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U jules_user"]
      interval: 10s
      timeout: 5s
      retries: 5
  
  # Redis Cache
  redis:
    image: redis:7-alpine
    container_name: jules-redis
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
  
  # Backend API
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: jules-backend
    environment:
      DATABASE_URL: postgresql+asyncpg://jules_user:${POSTGRES_PASSWORD}@postgres:5432/jules_db
      REDIS_URL: redis://redis:6379
      JWT_SECRET_KEY: ${JWT_SECRET_KEY}
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    ports:
      - "8000:8000"
    volumes:
      - ./backend:/app
      - agent_guides:/app/agent_guides
  
  # Frontend
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: jules-frontend
    environment:
      VITE_API_URL: http://localhost:8000
      VITE_WS_URL: ws://localhost:8000
    ports:
      - "3000:80"
    depends_on:
      - backend

volumes:
  postgres_data:
  redis_data:
  agent_guides:
```

---

## 📋 خطة التنفيذ المرحلية

### المرحلة 1: الإعداد الأساسي 
```
✅ إعداد البيئة التطويرية
  - تثبيت Python 3.11+
  - تثبيت Node.js 20+
  - إعداد PostgreSQL
  - إعداد Redis

✅ إنشاء هيكل المشروع
  - Backend (FastAPI)
  - Frontend (React + TypeScript)
  - Database Schema
  - Docker Configuration

✅ إعداد الأدوات الأساسية
  - Git Repository
  - Environment Variables
  - CI/CD Pipeline
```

### المرحلة 2: Backend Core 
```
✅ نظام المصادقة
  - User Registration
  - Login/Logout
  - JWT Implementation
  - Password Hashing

✅ إدارة مفاتيح API
  - API Key Storage (Encrypted)
  - Validation
  - Quota Management

✅ قاعدة البيانات
  - Models Implementation
  - Migrations (Alembic)
  - CRUD Operations
```

### المرحلة 3: Agent System 
```
✅ Gemini API Integration
  - Client Implementation
  - Connection Pooling
  - Error Handling
  - Retry Logic

✅ Agent Manager
  - Agent Creation
  - Guide File Loading
  - Prompt Engineering
  - Response Processing

✅ 11 Specialized Agents
  - Implementation
  - Testing
  - Optimization
```

### المرحلة 4: Orchestration Engine 
```
✅ Session Management
  - Session Creation
  - Phase Tracking
  - State Management

✅ Idea Generation
  - Story Architect Integration
  - Character Development Integration
  - Idea Formatting

✅ Review System
  - Independent Reviews
  - Score Calculation
  - Report Generation
```

### المرحلة 5: Tournament System 
```
✅ Tournament Manager
  - Turn Management
  - Argument Collection
  - Context Building

✅ Decision Engine
  - Voting System
  - Consensus Detection
  - Final Report Generation
```

### المرحلة 6: Frontend Implementation 
```
✅ UI Components
  - Design System (Tailwind + shadcn/ui)
  - Reusable Components
  - Forms

✅ Pages
  - Dashboard
  - Session Creation
  - Idea Generation View
  - Review Phase View
  - Tournament View
  - Final Decision View

✅ Real-time Updates
  - WebSocket Integration
  - Live Progress
  - Notifications
```

### المرحلة 7: Testing & Optimization 
```
✅ Testing
  - Unit Tests
  - Integration Tests
  - E2E Tests
  - Load Testing

✅ Performance Optimization
  - Database Query Optimization
  - Caching Strategy
  - API Response Time

✅ Security Audit
  - Penetration Testing
  - Vulnerability Scanning
  - Code Review
```

### المرحلة 8: Deployment & Launch 
```
✅ Production Setup
  - Server Configuration
  - Database Setup
  - SSL Certificates

✅ Deployment
  - Docker Deployment
  - Environment Configuration
  - Health Checks

✅ Monitoring
  - Logging Setup
  - Error Tracking (Sentry)
  - Performance Monitoring
```

---

## 🎯 معايير النجاح والتسليم

### معايير الجودة
```
✅ Code Quality
  - Type Safety (TypeScript, Pydantic)
  - No Code Smells
  - Proper Error Handling
  - Comprehensive Comments

✅ Performance
  - API Response < 500ms (95th percentile)
  - Database Query < 100ms
  - Page Load < 2s

✅ Security
  - All Inputs Validated
  - API Keys Encrypted
  - SQL Injection Protected
  - XSS Protected

✅ Testing
  - Unit Test Coverage > 80%
  - All Critical Paths Tested
  - E2E Tests for Main Flows

✅ Documentation
  - API Documentation (OpenAPI)
  - Code Comments
  - README Files
  - Deployment Guide
```

### التسليمات المطلوبة
```
📦 Source Code
  - Complete Backend Code
  - Complete Frontend Code
  - Database Migrations
  - Docker Configuration

📦 Documentation
  - API Documentation
  - User Guide
  - Admin Guide
  - Deployment Guide

📦 Testing
  - Test Suite
  - Test Coverage Report
  - Performance Test Results

📦 Deployment
  - Production-Ready Docker Images
  - Environment Configuration Templates
  - Deployment Scripts
```

---

## 🚀 ملاحظات نهائية للوكيل المطور

### أولويات التطوير
1. **الأمان أولاً**: لا تتنازل عن معايير الأمان أبداً
2. **الأداء**: كل endpoint يجب أن يكون محسناً
3. **معالجة الأخطاء**: كل سيناريو محتمل للفشل يجب معالجته
4. **UX/UI**: واجهة المستخدم يجب أن تكون بديهية وسلسة
5. **التوثيق**: كل function يجب أن تكون موثقة

### تقنيات يجب تجنبها
```
❌ No Mock Code
❌ No Placeholder Functions
❌ No Dummy Data in Production
❌ No console.log في Production
❌ No Hard-coded Secrets
```

### Best Practices المطلوبة
```
✅ Async/Await for All I/O
✅ Transaction Management for Database
✅ Proper Error Handling
✅ Input Validation
✅ Rate Limiting
✅ CORS Configuration
✅ Logging
✅ Monitoring
```

هذا السياق الهندسي يوفر الخريطة الكاملة لبناء نظام Jules كتطبيق ويب إنتاجي متكامل. كل التفاصيل التقنية، المعمارية، والأمنية موثقة بشكل شامل لضمان تنفيذ احترافي وجاهز للإنتاج.
