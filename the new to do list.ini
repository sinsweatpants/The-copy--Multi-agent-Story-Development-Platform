# ğŸš€ ÙƒÙˆØ¯ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ§Ù…Ù„ - Jules Narrative Development Platform
# ğŸš€ Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ Ø§Ù„Ø´Ø§Ù…Ù„: Ù†Ø¸Ø§Ù… Jules - Ù†Ø³Ø®Ø© Node.js/TypeScript

## ğŸ“‹ Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹

### Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
ØªØ·ÙˆÙŠØ± ØªØ·Ø¨ÙŠÙ‚ ÙˆÙŠØ¨ Ø¥Ù†ØªØ§Ø¬ÙŠ Ù…ØªÙƒØ§Ù…Ù„ Ø¨Ù€ **Node.js/TypeScript** ÙŠØ­ÙˆÙ„ Ù†Ø¸Ø§Ù… "Jules" - Ø§Ù„Ù…Ù†Ø¸Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„Ù‚ØµØµ - Ø¥Ù„Ù‰ Ù…Ù†ØµØ© ØªÙØ§Ø¹Ù„ÙŠØ© ØªØ¯ÙŠØ± 11 ÙˆÙƒÙŠÙ„Ø§Ù‹ Ù…ØªØ®ØµØµØ§Ù‹ (AI Agents) Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… **Gemini 2.5 Pro API**.

---

## ğŸ—ï¸ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ©

### Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ©: Modern Microservices-Ready Monolith

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CLIENT LAYER                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   React SPA (TypeScript + Vite)                  â”‚  â”‚
â”‚  â”‚   - State: Zustand + TanStack Query              â”‚  â”‚
â”‚  â”‚   - UI: Tailwind CSS + shadcn/ui                 â”‚  â”‚
â”‚  â”‚   - WebSocket: Socket.io-client                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“ HTTPS/WSS
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   API GATEWAY LAYER                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Fastify API Gateway                            â”‚  â”‚
â”‚  â”‚   - JWT Authentication (jsonwebtoken)            â”‚  â”‚
â”‚  â”‚   - Rate Limiting (@fastify/rate-limit)          â”‚  â”‚
â”‚  â”‚   - Request Validation (Zod)                     â”‚  â”‚
â”‚  â”‚   - CORS (@fastify/cors)                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               APPLICATION SERVICES LAYER                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Orchestrator   â”‚  â”‚ Agent Manager  â”‚  â”‚ Session  â”‚ â”‚
â”‚  â”‚ Service        â”‚  â”‚ Service        â”‚  â”‚ Service  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Idea Generator â”‚  â”‚ Review Engine  â”‚  â”‚ Decision â”‚ â”‚
â”‚  â”‚ Service        â”‚  â”‚ Service        â”‚  â”‚ Service  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  INTEGRATION LAYER                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Gemini AI Integration (@google/generative-ai)  â”‚  â”‚
â”‚  â”‚   - Connection Pool Management                   â”‚  â”‚
â”‚  â”‚   - Retry with Exponential Backoff (p-retry)     â”‚  â”‚
â”‚  â”‚   - Response Streaming                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   DATA LAYER                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ PostgreSQL  â”‚  â”‚   Redis     â”‚  â”‚  File Storage  â”‚ â”‚
â”‚  â”‚ (Prisma ORM)â”‚  â”‚  (ioredis)  â”‚  â”‚  (S3/Local)    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ Backend Stack - Node.js/TypeScript

### Ø¨Ù†ÙŠØ© Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„ÙƒØ§Ù…Ù„Ø©

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ database.config.ts      # Prisma configuration
â”‚   â”‚   â”œâ”€â”€ redis.config.ts         # Redis configuration
â”‚   â”‚   â”œâ”€â”€ gemini.config.ts        # Gemini API config
â”‚   â”‚   â””â”€â”€ app.config.ts           # App settings
â”‚   â”‚
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ agent.types.ts          # Agent type definitions
â”‚   â”‚   â”œâ”€â”€ session.types.ts        # Session types
â”‚   â”‚   â”œâ”€â”€ idea.types.ts           # Idea types
â”‚   â”‚   â”œâ”€â”€ tournament.types.ts     # Tournament types
â”‚   â”‚   â””â”€â”€ index.ts                # Export all types
â”‚   â”‚
â”‚   â”œâ”€â”€ schemas/                    # Zod validation schemas
â”‚   â”‚   â”œâ”€â”€ auth.schema.ts
â”‚   â”‚   â”œâ”€â”€ session.schema.ts
â”‚   â”‚   â”œâ”€â”€ agent.schema.ts
â”‚   â”‚   â”œâ”€â”€ idea.schema.ts
â”‚   â”‚   â”œâ”€â”€ tournament.schema.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ orchestrator.service.ts      # Master orchestrator
â”‚   â”‚   â”œâ”€â”€ agent-manager.service.ts     # 11 Agents manager
â”‚   â”‚   â”œâ”€â”€ session.service.ts           # Session lifecycle
â”‚   â”‚   â”œâ”€â”€ idea-generator.service.ts    # Idea generation
â”‚   â”‚   â”œâ”€â”€ review-engine.service.ts     # Review system
â”‚   â”‚   â”œâ”€â”€ tournament-manager.service.ts # Tournament logic
â”‚   â”‚   â”œâ”€â”€ decision-maker.service.ts    # Final decision
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ integrations/
â”‚   â”‚   â”œâ”€â”€ gemini/
â”‚   â”‚   â”‚   â”œâ”€â”€ gemini-client.ts         # Gemini API client
â”‚   â”‚   â”‚   â”œâ”€â”€ prompt-builder.ts        # Prompt engineering
â”‚   â”‚   â”‚   â”œâ”€â”€ streaming-handler.ts     # Stream responses
â”‚   â”‚   â”‚   â”œâ”€â”€ retry-handler.ts         # Retry logic
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ storage/
â”‚   â”‚       â”œâ”€â”€ file-storage.service.ts  # File uploads
â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.routes.ts           # Auth endpoints
â”‚   â”‚   â”‚   â”œâ”€â”€ session.routes.ts        # Session CRUD
â”‚   â”‚   â”‚   â”œâ”€â”€ agent.routes.ts          # Agent management
â”‚   â”‚   â”‚   â”œâ”€â”€ idea.routes.ts           # Idea generation
â”‚   â”‚   â”‚   â”œâ”€â”€ tournament.routes.ts     # Tournament
â”‚   â”‚   â”‚   â”œâ”€â”€ decision.routes.ts       # Decisions
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ middlewares/
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.middleware.ts       # JWT verification
â”‚   â”‚   â”‚   â”œâ”€â”€ error.middleware.ts      # Error handling
â”‚   â”‚   â”‚   â”œâ”€â”€ validate.middleware.ts   # Zod validation
â”‚   â”‚   â”‚   â”œâ”€â”€ rate-limit.middleware.ts # Rate limiting
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ websocket/
â”‚   â”‚       â”œâ”€â”€ connection-manager.ts    # WS connections
â”‚   â”‚       â”œâ”€â”€ event-handlers.ts        # WS events
â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ logger.ts                    # Winston logger
â”‚   â”‚   â”œâ”€â”€ encryption.ts                # Crypto utilities
â”‚   â”‚   â”œâ”€â”€ jwt.ts                       # JWT helpers
â”‚   â”‚   â”œâ”€â”€ errors.ts                    # Custom errors
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ app.ts                           # Fastify app setup
â”‚   â””â”€â”€ server.ts                        # Server entry point
â”‚
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ schema.prisma                    # Database schema
â”‚   â”œâ”€â”€ migrations/                      # DB migrations
â”‚   â””â”€â”€ seed.ts                          # Seed data
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ e2e/
â”‚
â”œâ”€â”€ .env.example
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ Dockerfile
â””â”€â”€ README.md
```

---

## ğŸ“ package.json Ø§Ù„ÙƒØ§Ù…Ù„

```json
{
  "name": "jules-backend",
  "version": "1.0.0",
  "description": "Jules Narrative Development Platform - Backend API",
  "main": "dist/server.js",
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc && tsc-alias",
    "start": "node dist/server.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:studio": "prisma studio",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@fastify/cors": "^9.0.1",
    "@fastify/helmet": "^11.1.1",
    "@fastify/jwt": "^8.0.0",
    "@fastify/multipart": "^8.1.0",
    "@fastify/rate-limit": "^9.1.0",
    "@fastify/static": "^7.0.1",
    "@fastify/websocket": "^10.0.1",
    "@google/generative-ai": "^0.21.0",
    "@prisma/client": "^5.19.0",
    "bcrypt": "^5.1.1",
    "dotenv": "^16.4.5",
    "fastify": "^4.28.1",
    "ioredis": "^5.4.1",
    "jsonwebtoken": "^9.0.2",
    "p-retry": "^6.2.0",
    "pino": "^9.3.2",
    "pino-pretty": "^11.2.2",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/jest": "^29.5.12",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^22.5.0",
    "@typescript-eslint/eslint-plugin": "^8.2.0",
    "@typescript-eslint/parser": "^8.2.0",
    "eslint": "^9.9.0",
    "jest": "^29.7.0",
    "prettier": "^3.3.3",
    "prisma": "^5.19.0",
    "ts-jest": "^29.2.4",
    "tsc-alias": "^1.8.10",
    "tsx": "^4.17.0",
    "typescript": "^5.5.4"
  },
  "engines": {
    "node": ">=20.0.0",
    "npm": ">=10.0.0"
  }
}
```

---

## ğŸ—„ï¸ Prisma Schema Ø§Ù„ÙƒØ§Ù…Ù„

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// User Management
// ============================================

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  hashedPassword String   @map("hashed_password")
  fullName      String?   @map("full_name")
  isActive      Boolean   @default(true) @map("is_active")
  isVerified    Boolean   @default(false) @map("is_verified")
  
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  lastLogin     DateTime? @map("last_login")
  
  // Relations
  apiKeys       ApiKey[]
  sessions      Session[]
  activityLogs  ActivityLog[]
  
  @@map("users")
  @@index([email])
  @@index([createdAt])
}

// ============================================
// API Key Management
// ============================================

model ApiKey {
  id            String    @id @default(uuid())
  userId        String    @map("user_id")
  encryptedKey  String    @map("encrypted_key")
  keyName       String?   @map("key_name")
  isActive      Boolean   @default(true) @map("is_active")
  quotaLimit    Int?      @map("quota_limit")
  quotaUsed     Int       @default(0) @map("quota_used")
  
  lastUsedAt    DateTime? @map("last_used_at")
  expiresAt     DateTime? @map("expires_at")
  createdAt     DateTime  @default(now()) @map("created_at")
  
  // Relations
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  sessions      Session[]
  
  @@map("api_keys")
  @@index([userId])
  @@index([isActive])
}

// ============================================
// Session Management
// ============================================

enum SessionStatus {
  INITIALIZED
  BRIEF_SUBMITTED
  IDEAS_GENERATING
  IDEAS_GENERATED
  REVIEWING
  TOURNAMENT_ACTIVE
  DECISION_MADE
  COMPLETED
  FAILED
}

enum SessionPhase {
  BRIEF
  IDEA_GENERATION
  INDEPENDENT_REVIEW
  TOURNAMENT
  FINAL_DECISION
}

model Session {
  id            String        @id @default(uuid())
  userId        String        @map("user_id")
  apiKeyId      String        @map("api_key_id")
  
  status        SessionStatus @default(INITIALIZED)
  currentPhase  SessionPhase  @default(BRIEF) @map("current_phase")
  
  sessionData   Json          @default("{}") @map("session_data")
  metadata      Json          @default("{}") @map("metadata")
  
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")
  completedAt   DateTime?     @map("completed_at")
  
  // Relations
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  apiKey        ApiKey        @relation(fields: [apiKeyId], references: [id])
  agents        Agent[]
  creativeBrief CreativeBrief?
  ideas         Idea[]
  reviews       Review[]
  tournament    Tournament?
  finalDecision FinalDecision?
  activityLogs  ActivityLog[]
  
  @@map("sessions")
  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

// ============================================
// Agent Management
// ============================================

enum AgentType {
  STORY_ARCHITECT
  REALISM_CRITIC
  STRATEGIC_ANALYST
  CHARACTER_DEVELOPMENT
  CHARACTER_EXPANSION
  WORLD_BUILDING
  DIALOGUE_VOICE
  THEME
  GENRE_TONE
  PACING
  CONFLICT_TENSION
}

model Agent {
  id            String     @id @default(uuid())
  sessionId     String     @map("session_id")
  
  agentType     AgentType  @map("agent_type")
  agentName     String     @map("agent_name")
  guideContent  String?    @map("guide_content") @db.Text
  
  modelName     String     @default("gemini-2.5-pro") @map("model_name")
  temperature   Float      @default(0.7)
  maxTokens     Int        @default(6000) @map("max_tokens")
  
  status        String     @default("initialized")
  isActive      Boolean    @default(true) @map("is_active")
  
  config        Json       @default("{}")
  statistics    Json       @default("{}")
  
  createdAt     DateTime   @default(now()) @map("created_at")
  
  // Relations
  session       Session    @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  reviews       Review[]
  
  @@map("agents")
  @@index([sessionId])
  @@index([agentType])
}

// ============================================
// Creative Brief
// ============================================

model CreativeBrief {
  id              String   @id @default(uuid())
  sessionId       String   @unique @map("session_id")
  
  coreIdea        String   @map("core_idea") @db.Text
  genre           String
  targetAudience  String?  @map("target_audience") @db.Text
  
  mainCharacters  Json     @default("[]") @map("main_characters")
  themes          Json     @default("[]")
  constraints     Json     @default("{}")
  preferences     Json     @default("{}")
  
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  
  // Relations
  session         Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  @@map("creative_briefs")
  @@index([sessionId])
}

// ============================================
// Ideas
// ============================================

model Idea {
  id                  String   @id @default(uuid())
  sessionId           String   @map("session_id")
  ideaNumber          Int      @map("idea_number")
  
  title               String
  logline             String   @db.Text
  synopsis            String   @db.Text
  
  threeActStructure   Json     @map("three_act_structure")
  mainCharacters      Json     @default("[]") @map("main_characters")
  keyScenes           Json     @default("[]") @map("key_scenes")
  thematicElements    Json     @default("[]") @map("thematic_elements")
  uniqueSellingPoints Json     @default("[]") @map("unique_selling_points")
  
  generatedByAgents   Json     @map("generated_by_agents")
  generationMetadata  Json     @default("{}") @map("generation_metadata")
  
  generatedAt         DateTime @default(now()) @map("generated_at")
  
  // Relations
  session             Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  reviews             Review[]
  winningDecisions    FinalDecision[] @relation("WinningIdea")
  losingDecisions     FinalDecision[] @relation("LosingIdea")
  
  @@unique([sessionId, ideaNumber])
  @@map("ideas")
  @@index([sessionId])
}

// ============================================
// Reviews
// ============================================

model Review {
  id                String   @id @default(uuid())
  sessionId         String   @map("session_id")
  agentId           String   @map("agent_id")
  ideaId            String   @map("idea_id")
  
  qualityScore      Float    @map("quality_score")
  noveltyScore      Float    @map("novelty_score")
  impactScore       Float    @map("impact_score")
  
  qualityAnalysis   String   @map("quality_analysis") @db.Text
  noveltyAnalysis   String   @map("novelty_analysis") @db.Text
  impactAnalysis    String   @map("impact_analysis") @db.Text
  
  strengths         Json     @default("[]")
  weaknesses        Json     @default("[]")
  recommendations   Json     @default("[]")
  
  overallVerdict    String   @map("overall_verdict") @db.Text
  reviewMetadata    Json     @default("{}") @map("review_metadata")
  
  createdAt         DateTime @default(now()) @map("created_at")
  
  // Relations
  session           Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  agent             Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
  idea              Idea     @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  
  @@unique([agentId, ideaId])
  @@map("reviews")
  @@index([sessionId])
  @@index([agentId])
  @@index([ideaId])
}

// ============================================
// Tournament
// ============================================

enum TournamentStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}

model Tournament {
  id              String           @id @default(uuid())
  sessionId       String           @unique @map("session_id")
  
  status          TournamentStatus @default(ACTIVE)
  currentTurn     Int              @default(0) @map("current_turn")
  maxTurns        Int              @default(8) @map("max_turns")
  
  tournamentData  Json             @default("{}") @map("tournament_data")
  
  startedAt       DateTime         @default(now()) @map("started_at")
  endedAt         DateTime?        @map("ended_at")
  
  // Relations
  session         Session          @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  turns           TournamentTurn[]
  finalDecision   FinalDecision?
  
  @@map("tournaments")
  @@index([sessionId])
}

// ============================================
// Tournament Turns
// ============================================

model TournamentTurn {
  id                  String     @id @default(uuid())
  tournamentId        String     @map("tournament_id")
  turnNumber          Int        @map("turn_number")
  
  participatingAgents Json       @map("participating_agents")
  arguments           Json       @default("[]")
  
  turnMetadata        Json       @default("{}") @map("turn_metadata")
  
  createdAt           DateTime   @default(now()) @map("created_at")
  
  // Relations
  tournament          Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  
  @@unique([tournamentId, turnNumber])
  @@map("tournament_turns")
  @@index([tournamentId])
  @@index([turnNumber])
}

// ============================================
// Final Decision
// ============================================

model FinalDecision {
  id                          String     @id @default(uuid())
  sessionId                   String     @unique @map("session_id")
  tournamentId                String     @map("tournament_id")
  
  winningIdeaId               String     @map("winning_idea_id")
  losingIdeaId                String     @map("losing_idea_id")
  
  decisionRationale           String     @map("decision_rationale") @db.Text
  keyStrengths                Json       @default("[]") @map("key_strengths")
  addressedWeaknesses         Json       @default("[]") @map("addressed_weaknesses")
  
  voteBreakdown               Json       @map("vote_breakdown")
  unanimous                   Boolean
  confidenceScore             Float      @map("confidence_score")
  
  implementationRecommendations Json     @default("[]") @map("implementation_recommendations")
  nextSteps                   Json       @default("[]") @map("next_steps")
  
  decisionMetadata            Json       @default("{}") @map("decision_metadata")
  
  createdAt                   DateTime   @default(now()) @map("created_at")
  
  // Relations
  session                     Session    @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  tournament                  Tournament @relation(fields: [tournamentId], references: [id])
  winningIdea                 Idea       @relation("WinningIdea", fields: [winningIdeaId], references: [id])
  losingIdea                  Idea       @relation("LosingIdea", fields: [losingIdeaId], references: [id])
  
  @@map("final_decisions")
  @@index([sessionId])
  @@index([winningIdeaId])
}

// ============================================
// Activity Logs
// ============================================

model ActivityLog {
  id                  String    @id @default(uuid())
  sessionId           String?   @map("session_id")
  userId              String?   @map("user_id")
  
  activityType        String    @map("activity_type")
  activityDescription String?   @map("activity_description") @db.Text
  
  activityData        Json      @default("{}") @map("activity_data")
  
  ipAddress           String?   @map("ip_address")
  userAgent           String?   @map("user_agent") @db.Text
  
  createdAt           DateTime  @default(now()) @map("created_at")
  
  // Relations
  session             Session?  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user                User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@map("activity_logs")
  @@index([sessionId])
  @@index([userId])
  @@index([activityType])
  @@index([createdAt])
}
```

---

## ğŸ”§ Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙƒÙˆÙŠÙ† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©

### tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "lib": ["ES2022"],
    "moduleResolution": "node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictPropertyInitialization": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "baseUrl": "./src",
    "paths": {
      "@/*": ["./*"],
      "@config/*": ["./config/*"],
      "@services/*": ["./services/*"],
      "@utils/*": ["./utils/*"],
      "@types/*": ["./types/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

### .env.example

```bash
# ============================================
# Application Configuration
# ============================================
NODE_ENV=development
PORT=8000
HOST=0.0.0.0

# ============================================
# Database Configuration
# ============================================
DATABASE_URL="postgresql://jules_user:password@localhost:5432/jules_db?schema=public"

# ============================================
# Redis Configuration
# ============================================
REDIS_URL="redis://localhost:6379"
REDIS_PASSWORD=
REDIS_DB=0

# ============================================
# JWT Configuration
# ============================================
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=30m
REFRESH_TOKEN_SECRET=your-refresh-token-secret
REFRESH_TOKEN_EXPIRES_IN=7d

# ============================================
# Encryption
# ============================================
ENCRYPTION_KEY=your-32-character-encryption-key-here

# ============================================
# Google Gemini API
# ============================================
GEMINI_API_KEY=your-gemini-api-key-here

# ============================================
# CORS Configuration
# ============================================
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:5173

# ============================================
# Rate Limiting
# ============================================
RATE_LIMIT_MAX=100
RATE_LIMIT_TIMEWINDOW=60000

# ============================================
# File Upload
# ============================================
MAX_FILE_SIZE=10485760
UPLOAD_DIR=./uploads

# ============================================
# Logging
# ============================================
LOG_LEVEL=info
```

---

## ğŸ’» Ø£Ù…Ø«Ù„Ø© Ø§Ù„ÙƒÙˆØ¯ Production-Ready

### 1. Gemini Client Integration

```typescript
// src/integrations/gemini/gemini-client.ts

import { GoogleGenerativeAI, GenerativeModel } from '@google/generative-ai';
import pRetry from 'p-retry';
import { logger } from '@/utils/logger';
import { GeminiAPIError, RateLimitError } from '@/utils/errors';

interface GeminiClientConfig {
  apiKey: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
}

interface GenerateContentOptions {
  prompt: string;
  systemInstruction?: string;
  temperature?: number;
  maxTokens?: number;
  stream?: boolean;
}

export class GeminiClient {
  private genAI: GoogleGenerativeAI;
  private model: GenerativeModel;
  private config: Required<GeminiClientConfig>;

  constructor(config: GeminiClientConfig) {
    this.config = {
      model: config.model || 'gemini-2.5-pro',
      temperature: config.temperature || 0.7,
      maxTokens: config.maxTokens || 8000,
      apiKey: config.apiKey,
    };

    this.genAI = new GoogleGenerativeAI(this.config.apiKey);
    this.model = this.genAI.getGenerativeModel({
      model: this.config.model,
    });

    logger.info('Gemini client initialized', {
      model: this.config.model,
    });
  }

  /**
   * Generate content with retry logic
   */
  async generateContent(
    options: GenerateContentOptions
  ): Promise<string> {
    const { prompt, systemInstruction, temperature, maxTokens } = options;

    try {
      const result = await pRetry(
        async () => {
          const response = await this.model.generateContent({
            contents: [
              {
                role: 'user',
                parts: [
                  {
                    text: systemInstruction
                      ? `${systemInstruction}\n\n${prompt}`
                      : prompt,
                  },
                ],
              },
            ],
            generationConfig: {
              temperature: temperature || this.config.temperature,
              maxOutputTokens: maxTokens || this.config.maxTokens,
            },
          });

          const text = response.response.text();
          
          if (!text) {
            throw new GeminiAPIError('Empty response from Gemini API');
          }

          return text;
        },
        {
          retries: 3,
          factor: 2,
          minTimeout: 1000,
          maxTimeout: 10000,
          onFailedAttempt: (error) => {
            logger.warn('Gemini API retry attempt', {
              attemptNumber: error.attemptNumber,
              retriesLeft: error.retriesLeft,
              error: error.message,
            });

            // Check for rate limiting
            if (error.message.includes('429') || error.message.includes('quota')) {
              throw new RateLimitError('Gemini API rate limit exceeded');
            }
          },
        }
      );

      logger.info('Content generated successfully', {
        promptLength: prompt.length,
        responseLength: result.length,
      });

      return result;
    } catch (error) {
      logger.error('Failed to generate content', {
        error: error instanceof Error ? error.message : String(error),
        prompt: prompt.substring(0, 100),
      });

      if (error instanceof RateLimitError) {
        throw error;
      }

      throw new GeminiAPIError(
        `Failed to generate content: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Generate content with streaming
   */
  async *generateContentStream(
    options: GenerateContentOptions
  ): AsyncGenerator<string, void, unknown> {
    const { prompt, systemInstruction, temperature, maxTokens } = options;

    try {
      const result = await this.model.generateContentStream({
        contents: [
          {
            role: 'user',
            parts: [
              {
                text: systemInstruction
                  ? `${systemInstruction}\n\n${prompt}`
                  : prompt,
              },
            ],
          },
        ],
        generationConfig: {
          temperature: temperature || this.config.temperature,
          maxOutputTokens: maxTokens || this.config.maxTokens,
        },
      });

      for await (const chunk of result.stream) {
        const text = chunk.text();
        if (text) {
          yield text;
        }
      }

      logger.info('Streaming content generation completed');
    } catch (error) {
      logger.error('Failed to stream content', {
        error: error instanceof Error ? error.message : String(error),
      });

      throw new GeminiAPIError(
        `Failed to stream content: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Count tokens in a prompt
   */
  async countTokens(text: string): Promise<number> {
    try {
      const result = await this.model.countTokens(text);
      return result.totalTokens;
    } catch (error) {
      logger.error('Failed to count tokens', {
        error: error instanceof Error ? error.message : String(error),
      });
      throw new GeminiAPIError('Failed to count tokens');
    }
  }
}

// Connection Pool Manager
export class GeminiClientPool {
  private clients: Map<string, GeminiClient> = new Map();
  private maxPoolSize: number;

  constructor(maxPoolSize: number = 5) {
    this.maxPoolSize = maxPoolSize;
  }

  getClient(apiKey: string, config?: Partial<GeminiClientConfig>): GeminiClient {
    const clientKey = `${apiKey}-${config?.model || 'default'}`;

    if (!this.clients.has(clientKey)) {
      if (this.clients.size >= this.maxPoolSize) {
        // Remove oldest client
        const firstKey = this.clients.keys().next().value;
        this.clients.delete(firstKey);
        logger.info('Removed oldest client from pool', { clientKey: firstKey });
      }

      const client = new GeminiClient({
        apiKey,
        ...config,
      });

      this.clients.set(clientKey, client);
      logger.info('Created new Gemini client', { clientKey });
    }

    return this.clients.get(clientKey)!;
  }

  clearPool(): void {
    this.clients.clear();
    logger.info('Cleared Gemini client pool');
  }

  getPoolSize(): number {
    return this.clients.size;
  }
}

export const geminiClientPool = new GeminiClientPool();

// src/types/agent.types.ts

export enum AgentType {
  STORY_ARCHITECT = 'STORY_ARCHITECT',
  REALISM_CRITIC = 'REALISM_CRITIC',
  STRATEGIC_ANALYST = 'STRATEGIC_ANALYST',
  CHARACTER_DEVELOPMENT = 'CHARACTER_DEVELOPMENT',
  CHARACTER_EXPANSION = 'CHARACTER_EXPANSION',
  WORLD_BUILDING = 'WORLD_BUILDING',
  DIALOGUE_VOICE = 'DIALOGUE_VOICE',
  THEME = 'THEME',
  GENRE_TONE = 'GENRE_TONE',
  PACING = 'PACING',
  CONFLICT_TENSION = 'CONFLICT_TENSION',
}

export interface AgentConfig {
  id: string;
  type: AgentType;
  name: string;
  guideFilePath: string;
  systemInstruction: string;
  temperature: number;
  maxTokens: number;
}

export interface AgentInstance {
  id: string;
  sessionId: string;
  type: AgentType;
  name: string;
  guideContent: string;
  config: AgentConfig;
  status: 'initialized' | 'active' | 'completed' | 'error';
  statistics: {
    totalCalls: number;
    totalTokensUsed: number;
    averageResponseTime: number;
  };
}

export interface AgentResponse {
  agentId: string;
  agentType: AgentType;
  content: string;
  metadata: {
    tokensUsed: number;
    responseTime: number;
    timestamp: Date;
  };
}

export interface ReviewOutput {
  agentId: string;
  agentType: AgentType;
  ideaId: string;
  scores: {
    quality: number;
    novelty: number;
    impact: number;
  };
  analysis: {
    quality: string;
    novelty: string;
    impact: string;
  };
  strengths: string[];
  weaknesses: string[];
  recommendations: string[];
  overallVerdict: string;
}

export const AGENT_CONFIGS: Record<AgentType, Omit<AgentConfig, 'id'>> = {
  [AgentType.STORY_ARCHITECT]: {
    type: AgentType.STORY_ARCHITECT,
    name: 'Ù…Ù‡Ù†Ø¯Ø³ Ø§Ù„Ù‚ØµØ©',
    guideFilePath: '/mnt/user-data/uploads/story_architect_agent.md',
    systemInstruction: 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ Ù…Ù‡Ù†Ø¯Ø³ Ø§Ù„Ù‚ØµØ© Ø§Ù„Ù…ØªØ®ØµØµ ÙÙŠ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø³Ø±Ø¯ÙŠØ© ÙˆØ§Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠ.',
    temperature: 0.7,
    maxTokens: 6000,
  },
  [AgentType.REALISM_CRITIC]: {
    type: AgentType.REALISM_CRITIC,
    name: 'Ù†Ø§Ù‚Ø¯ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©',
    guideFilePath: '/mnt/user-data/uploads/realism_critic_guide.md',
    systemInstruction: 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ Ù†Ø§Ù‚Ø¯ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ© Ø§Ù„Ù…ØªØ®ØµØµ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£ØµØ§Ù„Ø© ÙˆÙ…Ù†Ø·Ù‚ÙŠØ© Ø§Ù„Ù‚ØµØµ.',
    temperature: 0.6,
    maxTokens: 6000,
  },
  [AgentType.STRATEGIC_ANALYST]: {
    type: AgentType.STRATEGIC_ANALYST,
    name: 'Ø§Ù„Ù…Ø­Ù„Ù„ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ',
    guideFilePath: '/mnt/user-data/uploads/strategic_analyst_agent_guide.md',
    systemInstruction: 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ Ø§Ù„Ù…Ø­Ù„Ù„ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ Ø§Ù„Ù…ØªØ®ØµØµ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚ ÙˆØ§Ù„Ø¬Ø¯ÙˆÙ‰ Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©.',
    temperature: 0.5,
    maxTokens: 6000,
  },
  [AgentType.CHARACTER_DEVELOPMENT]: {
    type: AgentType.CHARACTER_DEVELOPMENT,
    name: 'ØªØ·ÙˆÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª',
    guideFilePath: '/mnt/user-data/uploads/character_development_agent.md',
    systemInstruction: 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ ØªØ·ÙˆÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…ØªØ®ØµØµ ÙÙŠ Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø© ÙˆØ§Ù„Ù†ÙØ³ÙŠØ©.',
    temperature: 0.8,
    maxTokens: 6000,
  },
  [AgentType.CHARACTER_EXPANSION]: {
    type: AgentType.CHARACTER_EXPANSION,
    name: 'ØªÙˆØ³ÙŠØ¹ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª',
    guideFilePath: '/mnt/user-data/uploads/character_expansion_agent_guide.md',
    systemInstruction: 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ ØªÙˆØ³ÙŠØ¹ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…ØªØ®ØµØµ ÙÙŠ ØªØ·ÙˆÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø«Ø§Ù†ÙˆÙŠØ© ÙˆØ§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¨ÙŠØ¦ÙŠ Ù„Ù„Ø´Ø®ØµÙŠØ§Øª.',
    temperature: 0.75,
    maxTokens: 6000,
  },
  [AgentType.WORLD_BUILDING]: {
    type: AgentType.WORLD_BUILDING,
    name: 'Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù„Ù…',
    guideFilePath: '/mnt/user-data/uploads/world_building_agent.md',
    systemInstruction: 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù„Ù… Ø§Ù„Ù…ØªØ®ØµØµ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø¹ÙˆØ§Ù„Ù… Ù…ÙˆØ«ÙˆÙ‚Ø© ÙˆØºØ§Ù…Ø±Ø©.',
    temperature: 0.7,
    maxTokens: 6000,
  },
  [AgentType.DIALOGUE_VOICE]: {
    type: AgentType.DIALOGUE_VOICE,
    name: 'Ø§Ù„Ø­ÙˆØ§Ø± ÙˆØ§Ù„ØµÙˆØª',
    guideFilePath: '/mnt/user-data/uploads/dialogue_voice_agent.md',
    systemInstruction: 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ Ø§Ù„Ø­ÙˆØ§Ø± ÙˆØ§Ù„ØµÙˆØª Ø§Ù„Ù…ØªØ®ØµØµ ÙÙŠ ØµÙŠØ§ØºØ© Ø­ÙˆØ§Ø±Ø§Øª Ø£ØµÙŠÙ„Ø© ÙˆÙ…Ù…ÙŠØ²Ø©.',
    temperature: 0.8,
    maxTokens: 6000,
  },
  [AgentType.THEME]: {
    type: AgentType.THEME,
    name: 'Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹',
    guideFilePath: '/mnt/user-data/uploads/theme_agent_guide.md',
    systemInstruction: 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„Ù…ØªØ®ØµØµ ÙÙŠ Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„Ø­Ù‚Ø§Ø¦Ù‚ Ø§Ù„ÙÙ„Ø³ÙÙŠØ© ÙˆØ§Ù„Ø¥Ù†Ø³Ø§Ù†ÙŠØ©.',
    temperature: 0.7,
    maxTokens: 6000,
  },
  [AgentType.GENRE_TONE]: {
    type: AgentType.GENRE_TONE,
    name: 'Ø§Ù„Ù†ÙˆØ¹ ÙˆØ§Ù„Ù†Ø¨Ø±Ø©',
    guideFilePath: '/mnt/user-data/uploads/genre_tone_agent.md',
    systemInstruction: 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ Ø§Ù„Ù†ÙˆØ¹ ÙˆØ§Ù„Ù†Ø¨Ø±Ø© Ø§Ù„Ù…ØªØ®ØµØµ ÙÙŠ Ø§Ù„ØªÙ†Ø§Ø³Ù‚ Ø§Ù„Ø¬ÙˆÙŠ ÙˆØ§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„Ø£Ø¯Ø¨ÙŠØ©.',
    temperature: 0.6,
    maxTokens: 6000,
  },
  [AgentType.PACING]: {
    type: AgentType.PACING,
    name: 'Ø§Ù„Ø³Ø±Ø¹Ø© ÙˆØ§Ù„Ø¥ÙŠÙ‚Ø§Ø¹',
    guideFilePath: '/mnt/user-data/uploads/pacing_agent_guide.md',
    systemInstruction: 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ Ø§Ù„Ø³Ø±Ø¹Ø© ÙˆØ§Ù„Ø¥ÙŠÙ‚Ø§Ø¹ Ø§Ù„Ù…ØªØ®ØµØµ ÙÙŠ Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ ØªØ¯ÙÙ‚ Ø§Ù„Ø³Ø±Ø¯ ÙˆØ§Ù„ØªÙˆØªØ±.',
    temperature: 0.65,
    maxTokens: 6000,
  },
  [AgentType.CONFLICT_TENSION]: {
    type: AgentType.CONFLICT_TENSION,
    name: 'Ø§Ù„ØµØ±Ø§Ø¹ ÙˆØ§Ù„ØªÙˆØªØ±',
    guideFilePath: '/mnt/user-data/uploads/conflict_tension_guide.md',
    systemInstruction: 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ Ø§Ù„ØµØ±Ø§Ø¹ ÙˆØ§Ù„ØªÙˆØªØ± Ø§Ù„Ù…ØªØ®ØµØµ ÙÙŠ ØªØµØ¹ÙŠØ¯ Ø§Ù„Ù…Ø®Ø§Ø·Ø± ÙˆØªØµÙ…ÙŠÙ… Ø§Ù„Ø¹Ù‚Ø¨Ø§Øª.',
    temperature: 0.7,
    maxTokens: 6000,
  },
};
```

---

### `src/types/session.types.ts`

```typescript
// src/types/session.types.ts

export enum SessionStatus {
  INITIALIZED = 'INITIALIZED',
  BRIEF_SUBMITTED = 'BRIEF_SUBMITTED',
  IDEAS_GENERATING = 'IDEAS_GENERATING',
  IDEAS_GENERATED = 'IDEAS_GENERATED',
  REVIEWING = 'REVIEWING',
  TOURNAMENT_ACTIVE = 'TOURNAMENT_ACTIVE',
  DECISION_MADE = 'DECISION_MADE',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
}

export enum SessionPhase {
  BRIEF = 'BRIEF',
  IDEA_GENERATION = 'IDEA_GENERATION',
  INDEPENDENT_REVIEW = 'INDEPENDENT_REVIEW',
  TOURNAMENT = 'TOURNAMENT',
  FINAL_DECISION = 'FINAL_DECISION',
}

export interface CreativeBrief {
  coreIdea: string;
  genre: string;
  targetAudience?: string;
  mainCharacters: Array<{
    name: string;
    role: string;
    description: string;
  }>;
  themes: string[];
  constraints?: Record<string, any>;
  preferences?: Record<string, any>;
}

export interface SessionData {
  brief?: CreativeBrief;
  ideas?: any[];
  reviews?: any[];
  tournament?: any;
  finalDecision?: any;
  metadata: {
    totalTokensUsed: number;
    totalDuration: number;
    phaseTimings: Record<SessionPhase, number>;
  };
}

export interface SessionProgress {
  sessionId: string;
  status: SessionStatus;
  currentPhase: SessionPhase;
  progress: {
    completed: string[];
    current: string;
    remaining: string[];
    percentage: number;
  };
  estimatedTimeRemaining?: number;
}
```

---

### `src/types/idea.types.ts`

```typescript
// src/types/idea.types.ts

export interface ThreeActStructure {
  actOne: {
    setup: string;
    incitingIncident: string;
    plotPoint1: string;
  };
  actTwo: {
    risingAction: string;
    midpoint: string;
    complications: string;
    plotPoint2: string;
  };
  actThree: {
    climax: string;
    resolution: string;
    newEquilibrium: string;
  };
}

export interface Character {
  name: string;
  role: string;
  description: string;
  arc?: string;
  motivation?: string;
  conflict?: string;
}

export interface KeyScene {
  sceneNumber: number;
  title: string;
  description: string;
  purpose: string;
  emotionalBeat: string;
}

export interface Idea {
  id: string;
  sessionId: string;
  ideaNumber: 1 | 2;
  title: string;
  logline: string;
  synopsis: string;
  threeActStructure: ThreeActStructure;
  mainCharacters: Character[];
  keyScenes: KeyScene[];
  thematicElements: string[];
  uniqueSellingPoints: string[];
  generatedBy: {
    storyArchitect: string;
    characterDevelopment: string;
  };
  metadata: {
    generatedAt: Date;
    tokensUsed: number;
    generationTime: number;
  };
}

export interface IdeaGenerationRequest {
  sessionId: string;
  brief: CreativeBrief;
  ideaNumber: 1 | 2;
}

export interface IdeaGenerationResponse {
  idea: Idea;
  success: boolean;
  error?: string;
}
```

---

### `src/types/tournament.types.ts`

```typescript
// src/types/tournament.types.ts

import { AgentType } from './agent.types';

export enum TournamentStatus {
  ACTIVE = 'ACTIVE',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED',
}

export interface TournamentArgument {
  agentId: string;
  agentType: AgentType;
  agentName: string;
  position: 'supporting_idea_1' | 'supporting_idea_2' | 'neutral';
  argument: string;
  keyPoints: string[];
  rebuttal?: string;
  timestamp: Date;
}

export interface TournamentTurn {
  turnNumber: number;
  participatingAgents: Array<{
    agentId: string;
    agentType: AgentType;
    agentName: string;
  }>;
  arguments: TournamentArgument[];
  summary: string;
  shiftInMomentum?: {
    before: { idea1Support: number; idea2Support: number };
    after: { idea1Support: number; idea2Support: number };
  };
}

export interface TournamentData {
  sessionId: string;
  idea1Id: string;
  idea2Id: string;
  turns: TournamentTurn[];
  currentTurn: number;
  maxTurns: number;
  status: TournamentStatus;
  startedAt: Date;
  endedAt?: Date;
}

export interface TournamentProgress {
  tournamentId: string;
  status: TournamentStatus;
  currentTurn: number;
  maxTurns: number;
  idea1Support: number;
  idea2Support: number;
  neutralAgents: number;
}
```

---

## ğŸ“ **2. Validation Schemas (Zod)**

### `src/schemas/auth.schema.ts`

```typescript
// src/schemas/auth.schema.ts

import { z } from 'zod';

export const registerSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
      'Password must contain uppercase, lowercase, number and special character'
    ),
  fullName: z.string().min(2, 'Full name must be at least 2 characters').optional(),
});

export const loginSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(1, 'Password is required'),
});

export const apiKeySchema = z.object({
  geminiApiKey: z
    .string()
    .min(20, 'Invalid API key format')
    .startsWith('AIza', 'Invalid Gemini API key format'),
  keyName: z.string().min(1, 'Key name is required').optional(),
  quotaLimit: z.number().positive().optional(),
});

export type RegisterInput = z.infer<typeof registerSchema>;
export type LoginInput = z.infer<typeof loginSchema>;
export type ApiKeyInput = z.infer<typeof apiKeySchema>;
```

---

### `src/schemas/session.schema.ts`

```typescript
// src/schemas/session.schema.ts

import { z } from 'zod';

const characterSchema = z.object({
  name: z.string().min(1, 'Character name is required'),
  role: z.string().min(1, 'Character role is required'),
  description: z.string().min(10, 'Character description must be at least 10 characters'),
});

export const creativeBriefSchema = z.object({
  coreIdea: z.string().min(50, 'Core idea must be at least 50 characters'),
  genre: z.string().min(3, 'Genre is required'),
  targetAudience: z.string().optional(),
  mainCharacters: z.array(characterSchema).min(1, 'At least one main character is required'),
  themes: z.array(z.string()).min(1, 'At least one theme is required'),
  constraints: z.record(z.any()).optional(),
  preferences: z.record(z.any()).optional(),
});

export const createSessionSchema = z.object({
  apiKeyId: z.string().uuid('Invalid API key ID'),
});

export const updateSessionStatusSchema = z.object({
  status: z.enum([
    'INITIALIZED',
    'BRIEF_SUBMITTED',
    'IDEAS_GENERATING',
    'IDEAS_GENERATED',
    'REVIEWING',
    'TOURNAMENT_ACTIVE',
    'DECISION_MADE',
    'COMPLETED',
    'FAILED',
  ]),
});

export type CreativeBriefInput = z.infer<typeof creativeBriefSchema>;
export type CreateSessionInput = z.infer<typeof createSessionSchema>;
export type UpdateSessionStatusInput = z.infer<typeof updateSessionStatusSchema>;
```

---

## ğŸ“ **3. Core Services**

### `src/services/agent-manager.service.ts`

```typescript
// src/services/agent-manager.service.ts

import { PrismaClient } from '@prisma/client';
import { readFile } from 'fs/promises';
import { AgentType, AgentInstance, AGENT_CONFIGS, AgentResponse } from '@/types/agent.types';
import { GeminiClient, geminiClientPool } from '@/integrations/gemini/gemini-client';
import { logger } from '@/utils/logger';
import { ServiceError } from '@/utils/errors';

export class AgentManagerService {
  private prisma: PrismaClient;

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
  }

  /**
   * Initialize all 11 agents for a session
   */
  async initializeAgents(sessionId: string, apiKey: string): Promise<AgentInstance[]> {
    try {
      logger.info('Initializing agents for session', { sessionId });

      const agentInstances: AgentInstance[] = [];

      for (const [agentType, config] of Object.entries(AGENT_CONFIGS)) {
        // Read guide content from file
        const guideContent = await this.loadGuideContent(config.guideFilePath);

        // Create agent in database
        const agent = await this.prisma.agent.create({
          data: {
            sessionId,
            agentType: agentType as AgentType,
            agentName: config.name,
            guideContent,
            modelName: 'gemini-2.5-pro',
            temperature: config.temperature,
            maxTokens: config.maxTokens,
            status: 'initialized',
            config: config as any,
            statistics: {
              totalCalls: 0,
              totalTokensUsed: 0,
              averageResponseTime: 0,
            },
          },
        });

        agentInstances.push({
          id: agent.id,
          sessionId: agent.sessionId,
          type: agent.agentType as AgentType,
          name: agent.agentName,
          guideContent: agent.guideContent || '',
          config: agent.config as any,
          status: 'initialized',
          statistics: agent.statistics as any,
        });
      }

      logger.info('All agents initialized successfully', {
        sessionId,
        agentCount: agentInstances.length,
      });

      return agentInstances;
    } catch (error) {
      logger.error('Failed to initialize agents', {
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to initialize agents', 500);
    }
  }

  /**
   * Load guide content from file
   */
  private async loadGuideContent(filePath: string): Promise<string> {
    try {
      const content = await readFile(filePath, 'utf-8');
      return content;
    } catch (error) {
      logger.warn('Failed to load guide content from file', {
        filePath,
        error: error instanceof Error ? error.message : String(error),
      });
      // Return default instruction if file not found
      return 'Ø£Ù†Øª ÙˆÙƒÙŠÙ„ Ù…ØªØ®ØµØµ ÙÙŠ ØªØ·ÙˆÙŠØ± Ø§Ù„Ù‚ØµØµ. Ø§ØªØ¨Ø¹ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø¨Ø¯Ù‚Ø©.';
    }
  }

  /**
   * Execute agent with prompt
   */
  async executeAgent(
    agentId: string,
    prompt: string,
    apiKey: string,
    stream: boolean = false
  ): Promise<AgentResponse> {
    const startTime = Date.now();

    try {
      // Get agent from database
      const agent = await this.prisma.agent.findUnique({
        where: { id: agentId },
      });

      if (!agent) {
        throw new ServiceError('Agent not found', 404);
      }

      // Get Gemini client
      const geminiClient = geminiClientPool.getClient(apiKey, {
        model: agent.modelName,
        temperature: agent.temperature,
        maxTokens: agent.maxTokens,
      });

      // Build full prompt with guide content
      const systemInstruction = agent.guideContent || '';

      // Generate content
      const content = await geminiClient.generateContent({
        prompt,
        systemInstruction,
        temperature: agent.temperature,
        maxTokens: agent.maxTokens,
      });

      const responseTime = Date.now() - startTime;

      // Update agent statistics
      const currentStats = agent.statistics as any;
      const newStats = {
        totalCalls: (currentStats.totalCalls || 0) + 1,
        totalTokensUsed: (currentStats.totalTokensUsed || 0) + content.length / 4, // Rough estimate
        averageResponseTime:
          ((currentStats.averageResponseTime || 0) * (currentStats.totalCalls || 0) + responseTime) /
          ((currentStats.totalCalls || 0) + 1),
      };

      await this.prisma.agent.update({
        where: { id: agentId },
        data: {
          statistics: newStats,
          status: 'active',
        },
      });

      logger.info('Agent executed successfully', {
        agentId,
        agentType: agent.agentType,
        responseTime,
        contentLength: content.length,
      });

      return {
        agentId: agent.id,
        agentType: agent.agentType as AgentType,
        content,
        metadata: {
          tokensUsed: content.length / 4,
          responseTime,
          timestamp: new Date(),
        },
      };
    } catch (error) {
      logger.error('Failed to execute agent', {
        agentId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Get all agents for a session
   */
  async getSessionAgents(sessionId: string): Promise<AgentInstance[]> {
    try {
      const agents = await this.prisma.agent.findMany({
        where: { sessionId },
        orderBy: { createdAt: 'asc' },
      });

      return agents.map((agent) => ({
        id: agent.id,
        sessionId: agent.sessionId,
        type: agent.agentType as AgentType,
        name: agent.agentName,
        guideContent: agent.guideContent || '',
        config: agent.config as any,
        status: agent.status as any,
        statistics: agent.statistics as any,
      }));
    } catch (error) {
      logger.error('Failed to get session agents', {
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to get session agents', 500);
    }
  }

  /**
   * Get agent by type
   */
  async getAgentByType(sessionId: string, agentType: AgentType): Promise<AgentInstance | null> {
    try {
      const agent = await this.prisma.agent.findFirst({
        where: {
          sessionId,
          agentType,
        },
      });

      if (!agent) {
        return null;
      }

      return {
        id: agent.id,
        sessionId: agent.sessionId,
        type: agent.agentType as AgentType,
        name: agent.agentName,
        guideContent: agent.guideContent || '',
        config: agent.config as any,
        status: agent.status as any,
        statistics: agent.statistics as any,
      };
    } catch (error) {
      logger.error('Failed to get agent by type', {
        sessionId,
        agentType,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to get agent by type', 500);
    }
  }
}



// src/services/orchestrator.service.ts

import { PrismaClient } from '@prisma/client';
import { SessionStatus, SessionPhase, SessionProgress } from '@/types/session.types';
import { AgentManagerService } from './agent-manager.service';
import { SessionService } from './session.service';
import { IdeaGeneratorService } from './idea-generator.service';
import { ReviewEngineService } from './review-engine.service';
import { TournamentManagerService } from './tournament-manager.service';
import { DecisionMakerService } from './decision-maker.service';
import { logger } from '@/utils/logger';
import { ServiceError } from '@/utils/errors';
import { EventEmitter } from 'events';

interface OrchestratorConfig {
  sessionId: string;
  userId: string;
  apiKey: string;
}

export class OrchestratorService extends EventEmitter {
  private prisma: PrismaClient;
  private config: OrchestratorConfig;
  private agentManager: AgentManagerService;
  private sessionService: SessionService;
  private ideaGenerator: IdeaGeneratorService;
  private reviewEngine: ReviewEngineService;
  private tournamentManager: TournamentManagerService;
  private decisionMaker: DecisionMakerService;

  constructor(prisma: PrismaClient, config: OrchestratorConfig) {
    super();
    this.prisma = prisma;
    this.config = config;

    // Initialize services
    this.agentManager = new AgentManagerService(prisma);
    this.sessionService = new SessionService(prisma);
    this.ideaGenerator = new IdeaGeneratorService(prisma, this.agentManager);
    this.reviewEngine = new ReviewEngineService(prisma, this.agentManager);
    this.tournamentManager = new TournamentManagerService(prisma, this.agentManager);
    this.decisionMaker = new DecisionMakerService(prisma, this.agentManager);

    logger.info('Orchestrator initialized', { sessionId: config.sessionId });
  }

  /**
   * Start the complete narrative development process
   */
  async startProcess(): Promise<void> {
    try {
      logger.info('Starting narrative development process', {
        sessionId: this.config.sessionId,
      });

      // Phase 1: Initialize agents
      await this.executePhase(SessionPhase.BRIEF, async () => {
        await this.initializeAgentsPhase();
      });

      // Phase 2: Generate ideas
      await this.executePhase(SessionPhase.IDEA_GENERATION, async () => {
        await this.generateIdeasPhase();
      });

      // Phase 3: Independent reviews
      await this.executePhase(SessionPhase.INDEPENDENT_REVIEW, async () => {
        await this.conductReviewsPhase();
      });

      // Phase 4: Tournament
      await this.executePhase(SessionPhase.TOURNAMENT, async () => {
        await this.conductTournamentPhase();
      });

      // Phase 5: Final decision
      await this.executePhase(SessionPhase.FINAL_DECISION, async () => {
        await this.makeFinalDecisionPhase();
      });

      // Mark session as completed
      await this.sessionService.updateSessionStatus(
        this.config.sessionId,
        SessionStatus.COMPLETED
      );

      logger.info('Narrative development process completed successfully', {
        sessionId: this.config.sessionId,
      });

      this.emit('process:completed', { sessionId: this.config.sessionId });
    } catch (error) {
      logger.error('Narrative development process failed', {
        sessionId: this.config.sessionId,
        error: error instanceof Error ? error.message : String(error),
      });

      await this.sessionService.updateSessionStatus(
        this.config.sessionId,
        SessionStatus.FAILED
      );

      this.emit('process:failed', {
        sessionId: this.config.sessionId,
        error: error instanceof Error ? error.message : String(error),
      });

      throw error;
    }
  }

  /**
   * Execute a phase with error handling and progress tracking
   */
  private async executePhase(
    phase: SessionPhase,
    executor: () => Promise<void>
  ): Promise<void> {
    const startTime = Date.now();

    try {
      logger.info(`Starting phase: ${phase}`, { sessionId: this.config.sessionId });

      // Update session phase
      await this.sessionService.updateSessionPhase(this.config.sessionId, phase);

      this.emit('phase:started', {
        sessionId: this.config.sessionId,
        phase,
      });

      // Execute phase logic
      await executor();

      const duration = Date.now() - startTime;

      logger.info(`Phase completed: ${phase}`, {
        sessionId: this.config.sessionId,
        duration,
      });

      this.emit('phase:completed', {
        sessionId: this.config.sessionId,
        phase,
        duration,
      });
    } catch (error) {
      logger.error(`Phase failed: ${phase}`, {
        sessionId: this.config.sessionId,
        error: error instanceof Error ? error.message : String(error),
      });

      this.emit('phase:failed', {
        sessionId: this.config.sessionId,
        phase,
        error: error instanceof Error ? error.message : String(error),
      });

      throw error;
    }
  }

  /**
   * Phase 1: Initialize all agents
   */
  private async initializeAgentsPhase(): Promise<void> {
    logger.info('Initializing agents', { sessionId: this.config.sessionId });

    const agents = await this.agentManager.initializeAgents(
      this.config.sessionId,
      this.config.apiKey
    );

    this.emit('agents:initialized', {
      sessionId: this.config.sessionId,
      agentCount: agents.length,
    });

    logger.info('Agents initialized successfully', {
      sessionId: this.config.sessionId,
      agentCount: agents.length,
    });
  }

  /**
   * Phase 2: Generate two competing ideas
   */
  private async generateIdeasPhase(): Promise<void> {
    logger.info('Generating ideas', { sessionId: this.config.sessionId });

    await this.sessionService.updateSessionStatus(
      this.config.sessionId,
      SessionStatus.IDEAS_GENERATING
    );

    // Generate both ideas in parallel
    const [idea1, idea2] = await Promise.all([
      this.ideaGenerator.generateIdea(this.config.sessionId, this.config.apiKey, 1),
      this.ideaGenerator.generateIdea(this.config.sessionId, this.config.apiKey, 2),
    ]);

    await this.sessionService.updateSessionStatus(
      this.config.sessionId,
      SessionStatus.IDEAS_GENERATED
    );

    this.emit('ideas:generated', {
      sessionId: this.config.sessionId,
      ideas: [idea1, idea2],
    });

    logger.info('Ideas generated successfully', {
      sessionId: this.config.sessionId,
    });
  }

  /**
   * Phase 3: Conduct independent reviews by all agents
   */
  private async conductReviewsPhase(): Promise<void> {
    logger.info('Conducting reviews', { sessionId: this.config.sessionId });

    await this.sessionService.updateSessionStatus(
      this.config.sessionId,
      SessionStatus.REVIEWING
    );

    const reviews = await this.reviewEngine.conductAllReviews(
      this.config.sessionId,
      this.config.apiKey
    );

    this.emit('reviews:completed', {
      sessionId: this.config.sessionId,
      reviewCount: reviews.length,
    });

    logger.info('Reviews completed successfully', {
      sessionId: this.config.sessionId,
      reviewCount: reviews.length,
    });
  }

  /**
   * Phase 4: Conduct tournament discussion
   */
  private async conductTournamentPhase(): Promise<void> {
    logger.info('Starting tournament', { sessionId: this.config.sessionId });

    await this.sessionService.updateSessionStatus(
      this.config.sessionId,
      SessionStatus.TOURNAMENT_ACTIVE
    );

    const tournament = await this.tournamentManager.conductTournament(
      this.config.sessionId,
      this.config.apiKey
    );

    this.emit('tournament:completed', {
      sessionId: this.config.sessionId,
      tournamentId: tournament.id,
      turnsCompleted: tournament.currentTurn,
    });

    logger.info('Tournament completed successfully', {
      sessionId: this.config.sessionId,
      turnsCompleted: tournament.currentTurn,
    });
  }

  /**
   * Phase 5: Make final decision
   */
  private async makeFinalDecisionPhase(): Promise<void> {
    logger.info('Making final decision', { sessionId: this.config.sessionId });

    const decision = await this.decisionMaker.makeFinalDecision(
      this.config.sessionId,
      this.config.apiKey
    );

    await this.sessionService.updateSessionStatus(
      this.config.sessionId,
      SessionStatus.DECISION_MADE
    );

    this.emit('decision:made', {
      sessionId: this.config.sessionId,
      decisionId: decision.id,
      winningIdeaId: decision.winningIdeaId,
    });

    logger.info('Final decision made successfully', {
      sessionId: this.config.sessionId,
      winningIdeaId: decision.winningIdeaId,
    });
  }

  /**
   * Get current session progress
   */
  async getProgress(): Promise<SessionProgress> {
    const session = await this.sessionService.getSessionById(this.config.sessionId);

    if (!session) {
      throw new ServiceError('Session not found', 404);
    }

    const phases = Object.values(SessionPhase);
    const currentPhaseIndex = phases.indexOf(session.currentPhase);

    return {
      sessionId: session.id,
      status: session.status,
      currentPhase: session.currentPhase,
      progress: {
        completed: phases.slice(0, currentPhaseIndex),
        current: session.currentPhase,
        remaining: phases.slice(currentPhaseIndex + 1),
        percentage: Math.round((currentPhaseIndex / phases.length) * 100),
      },
    };
  }

  /**
   * Cancel the process
   */
  async cancel(): Promise<void> {
    logger.info('Cancelling process', { sessionId: this.config.sessionId });

    await this.sessionService.updateSessionStatus(
      this.config.sessionId,
      SessionStatus.FAILED
    );

    this.emit('process:cancelled', { sessionId: this.config.sessionId });
  }
}
```

---

### `src/services/session.service.ts`

```typescript
// src/services/session.service.ts

import { PrismaClient, Session } from '@prisma/client';
import { SessionStatus, SessionPhase, CreativeBrief } from '@/types/session.types';
import { logger } from '@/utils/logger';
import { ServiceError } from '@/utils/errors';

export class SessionService {
  private prisma: PrismaClient;

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
  }

  /**
   * Create a new session
   */
  async createSession(userId: string, apiKeyId: string): Promise<Session> {
    try {
      const session = await this.prisma.session.create({
        data: {
          userId,
          apiKeyId,
          status: SessionStatus.INITIALIZED,
          currentPhase: SessionPhase.BRIEF,
          sessionData: {},
          metadata: {},
        },
      });

      logger.info('Session created', {
        sessionId: session.id,
        userId,
      });

      return session;
    } catch (error) {
      logger.error('Failed to create session', {
        userId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to create session', 500);
    }
  }

  /**
   * Get session by ID
   */
  async getSessionById(sessionId: string): Promise<Session | null> {
    try {
      return await this.prisma.session.findUnique({
        where: { id: sessionId },
        include: {
          user: {
            select: {
              id: true,
              email: true,
              fullName: true,
            },
          },
          creativeBrief: true,
          ideas: true,
          reviews: true,
          tournament: true,
          finalDecision: true,
        },
      });
    } catch (error) {
      logger.error('Failed to get session', {
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to get session', 500);
    }
  }

  /**
   * Get user sessions
   */
  async getUserSessions(
    userId: string,
    limit: number = 20,
    offset: number = 0
  ): Promise<{ sessions: Session[]; total: number }> {
    try {
      const [sessions, total] = await Promise.all([
        this.prisma.session.findMany({
          where: { userId },
          orderBy: { createdAt: 'desc' },
          take: limit,
          skip: offset,
          include: {
            creativeBrief: true,
            finalDecision: {
              include: {
                winningIdea: true,
              },
            },
          },
        }),
        this.prisma.session.count({
          where: { userId },
        }),
      ]);

      return { sessions, total };
    } catch (error) {
      logger.error('Failed to get user sessions', {
        userId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to get user sessions', 500);
    }
  }

  /**
   * Submit creative brief
   */
  async submitCreativeBrief(
    sessionId: string,
    brief: CreativeBrief
  ): Promise<void> {
    try {
      await this.prisma.$transaction([
        this.prisma.creativeBrief.create({
          data: {
            sessionId,
            coreIdea: brief.coreIdea,
            genre: brief.genre,
            targetAudience: brief.targetAudience,
            mainCharacters: brief.mainCharacters,
            themes: brief.themes,
            constraints: brief.constraints || {},
            preferences: brief.preferences || {},
          },
        }),
        this.prisma.session.update({
          where: { id: sessionId },
          data: {
            status: SessionStatus.BRIEF_SUBMITTED,
            sessionData: {
              brief,
            },
          },
        }),
      ]);

      logger.info('Creative brief submitted', { sessionId });
    } catch (error) {
      logger.error('Failed to submit creative brief', {
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to submit creative brief', 500);
    }
  }

  /**
   * Update session status
   */
  async updateSessionStatus(
    sessionId: string,
    status: SessionStatus
  ): Promise<void> {
    try {
      await this.prisma.session.update({
        where: { id: sessionId },
        data: {
          status,
          ...(status === SessionStatus.COMPLETED && {
            completedAt: new Date(),
          }),
        },
      });

      logger.info('Session status updated', {
        sessionId,
        status,
      });
    } catch (error) {
      logger.error('Failed to update session status', {
        sessionId,
        status,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to update session status', 500);
    }
  }

  /**
   * Update session phase
   */
  async updateSessionPhase(
    sessionId: string,
    phase: SessionPhase
  ): Promise<void> {
    try {
      await this.prisma.session.update({
        where: { id: sessionId },
        data: { currentPhase: phase },
      });

      logger.info('Session phase updated', {
        sessionId,
        phase,
      });
    } catch (error) {
      logger.error('Failed to update session phase', {
        sessionId,
        phase,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to update session phase', 500);
    }
  }

  /**
   * Delete session
   */
  async deleteSession(sessionId: string, userId: string): Promise<void> {
    try {
      // Verify ownership
      const session = await this.prisma.session.findUnique({
        where: { id: sessionId },
        select: { userId: true },
      });

      if (!session) {
        throw new ServiceError('Session not found', 404);
      }

      if (session.userId !== userId) {
        throw new ServiceError('Unauthorized', 403);
      }

      await this.prisma.session.delete({
        where: { id: sessionId },
      });

      logger.info('Session deleted', {
        sessionId,
        userId,
      });
    } catch (error) {
      if (error instanceof ServiceError) {
        throw error;
      }

      logger.error('Failed to delete session', {
        sessionId,
        userId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to delete session', 500);
    }
  }

  /**
   * Log activity
   */
  async logActivity(
    sessionId: string,
    userId: string,
    activityType: string,
    activityData: any
  ): Promise<void> {
    try {
      await this.prisma.activityLog.create({
        data: {
          sessionId,
          userId,
          activityType,
          activityData,
        },
      });
    } catch (error) {
      // Don't throw error for activity logging failures
      logger.warn('Failed to log activity', {
        sessionId,
        activityType,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }
}
```

---

### `src/services/idea-generator.service.ts`

```typescript
// src/services/idea-generator.service.ts

import { PrismaClient } from '@prisma/client';
import { Idea, ThreeActStructure, Character, KeyScene } from '@/types/idea.types';
import { AgentType } from '@/types/agent.types';
import { AgentManagerService } from './agent-manager.service';
import { logger } from '@/utils/logger';
import { ServiceError } from '@/utils/errors';

export class IdeaGeneratorService {
  private prisma: PrismaClient;
  private agentManager: AgentManagerService;

  constructor(prisma: PrismaClient, agentManager: AgentManagerService) {
    this.prisma = prisma;
    this.agentManager = agentManager;
  }

  /**
   * Generate a complete idea
   */
  async generateIdea(
    sessionId: string,
    apiKey: string,
    ideaNumber: 1 | 2
  ): Promise<Idea> {
    const startTime = Date.now();

    try {
      logger.info(`Generating idea ${ideaNumber}`, { sessionId });

      // Get creative brief
      const brief = await this.prisma.creativeBrief.findUnique({
        where: { sessionId },
      });

      if (!brief) {
        throw new ServiceError('Creative brief not found', 404);
      }

      // Get Story Architect and Character Development agents
      const storyArchitect = await this.agentManager.getAgentByType(
        sessionId,
        AgentType.STORY_ARCHITECT
      );

      const characterDev = await this.agentManager.getAgentByType(
        sessionId,
        AgentType.CHARACTER_DEVELOPMENT
      );

      if (!storyArchitect || !characterDev) {
        throw new ServiceError('Required agents not found', 404);
      }

      // Build collaborative prompt
      const prompt = this.buildIdeaPrompt(brief, ideaNumber);

      // Execute Story Architect
      logger.info('Executing Story Architect', { sessionId, ideaNumber });
      const storyResponse = await this.agentManager.executeAgent(
        storyArchitect.id,
        prompt,
        apiKey
      );

      // Parse story structure
      const storyStructure = this.parseStoryStructure(storyResponse.content);

      // Execute Character Development with story context
      logger.info('Executing Character Development', { sessionId, ideaNumber });
      const characterPrompt = this.buildCharacterPrompt(brief, storyStructure);
      const characterResponse = await this.agentManager.executeAgent(
        characterDev.id,
        characterPrompt,
        apiKey
      );

      // Parse character details
      const characters = this.parseCharacters(characterResponse.content);

      // Combine into complete idea
      const idea: Omit<Idea, 'id'> = {
        sessionId,
        ideaNumber,
        title: storyStructure.title,
        logline: storyStructure.logline,
        synopsis: storyStructure.synopsis,
        threeActStructure: storyStructure.threeActStructure,
        mainCharacters: characters,
        keyScenes: storyStructure.keyScenes,
        thematicElements: storyStructure.thematicElements,
        uniqueSellingPoints: storyStructure.uniqueSellingPoints,
        generatedBy: {
          storyArchitect: storyArchitect.id,
          characterDevelopment: characterDev.id,
        },
        metadata: {
          generatedAt: new Date(),
          tokensUsed:
            storyResponse.metadata.tokensUsed + characterResponse.metadata.tokensUsed,
          generationTime: Date.now() - startTime,
        },
      };

      // Save to database
      const savedIdea = await this.prisma.idea.create({
        data: {
          sessionId: idea.sessionId,
          ideaNumber: idea.ideaNumber,
          title: idea.title,
          logline: idea.logline,
          synopsis: idea.synopsis,
          threeActStructure: idea.threeActStructure as any,
          mainCharacters: idea.mainCharacters as any,
          keyScenes: idea.keyScenes as any,
          thematicElements: idea.thematicElements,
          uniqueSellingPoints: idea.uniqueSellingPoints,
          generatedByAgents: idea.generatedBy as any,
          generationMetadata: idea.metadata as any,
        },
      });

      logger.info(`Idea ${ideaNumber} generated successfully`, {
        sessionId,
        ideaId: savedIdea.id,
        generationTime: Date.now() - startTime,
      });

      return {
        id: savedIdea.id,
        ...idea,
      };
    } catch (error) {
      logger.error(`Failed to generate idea ${ideaNumber}`, {
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Build prompt for story architect
   */
  private buildIdeaPrompt(brief: any, ideaNumber: number): string {
    return `
# Ù…Ù‡Ù…Ø©: ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ù‚ØµØµÙŠØ© Ø±Ù‚Ù… ${ideaNumber}

## Ø§Ù„Ù…ÙˆØ¬Ø² Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹ÙŠ:
**Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:** ${brief.coreIdea}
**Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø£Ø¯Ø¨ÙŠ:** ${brief.genre}
**Ø§Ù„Ø¬Ù…Ù‡ÙˆØ± Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù:** ${brief.targetAudience || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}

**Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:**
${JSON.stringify(brief.mainCharacters, null, 2)}

**Ø§Ù„Ù…ÙˆØ§Ø¶ÙŠØ¹:**
${brief.themes.join(', ')}

## Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:
Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ ÙÙƒØ±Ø© Ù‚ØµØµÙŠØ© Ù…ØªÙƒØ§Ù…Ù„Ø© ÙˆØªÙØµÙŠÙ„ÙŠØ© ØªØªØ¶Ù…Ù†:

1. **Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:** Ø¹Ù†ÙˆØ§Ù† Ø¬Ø°Ø§Ø¨ ÙˆÙ…Ø¹Ø¨Ø±
2. **Ø§Ù„Ù„ÙˆØ¬Ù„Ø§ÙŠÙ†:** Ø¬Ù…Ù„Ø© ÙˆØ§Ø­Ø¯Ø© ØªÙ„Ø®Øµ Ø§Ù„Ù‚ØµØ© (25-35 ÙƒÙ„Ù…Ø©)
3. **Ø§Ù„Ù…Ù„Ø®Øµ:** Ù…Ù„Ø®Øµ Ø´Ø§Ù…Ù„ Ù„Ù„Ù‚ØµØ© (200-300 ÙƒÙ„Ù…Ø©)
4. **Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø«Ù„Ø§Ø«ÙŠØ©:**
   - Ø§Ù„ÙØµÙ„ Ø§Ù„Ø£ÙˆÙ„: Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ØŒ Ø§Ù„Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ù…Ø­ÙØ²Ø©ØŒ Ù†Ù‚Ø·Ø© Ø§Ù„ØªØ­ÙˆÙ„ 1
   - Ø§Ù„ÙØµÙ„ Ø§Ù„Ø«Ø§Ù†ÙŠ: Ø§Ù„ØµØ±Ø§Ø¹ Ø§Ù„Ù…ØªØµØ§Ø¹Ø¯ØŒ Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ù†ØªØµÙØŒ Ù†Ù‚Ø·Ø© Ø§Ù„ØªØ­ÙˆÙ„ 2
   - Ø§Ù„ÙØµÙ„ Ø§Ù„Ø«Ø§Ù„Ø«: Ø§Ù„Ø°Ø±ÙˆØ©ØŒ Ø§Ù„Ø­Ù„ØŒ Ø§Ù„ØªÙˆØ§Ø²Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯
5. **Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:** 5-7 Ù…Ø´Ø§Ù‡Ø¯ Ù…Ø­ÙˆØ±ÙŠØ©
6. **Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ÙŠØ©:** Ø§Ù„Ù…ÙˆØ§Ø¶ÙŠØ¹ Ø§Ù„ÙÙ„Ø³ÙÙŠØ© ÙˆØ§Ù„Ø¥Ù†Ø³Ø§Ù†ÙŠØ©
7. **Ù†Ù‚Ø§Ø· Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„ÙØ±ÙŠØ¯Ø©:** Ù…Ø§ ÙŠÙ…ÙŠØ² Ù‡Ø°Ù‡ Ø§Ù„Ù‚ØµØ©

**ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©:**
Ø§Ø³ØªØ®Ø¯Ù… JSON Ø¨Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„ØªØ§Ù„ÙŠ:
\`\`\`json
{
  "title": "...",
  "logline": "...",
  "synopsis": "...",
  "threeActStructure": {
    "actOne": {
      "setup": "...",
      "incitingIncident": "...",
      "plotPoint1": "..."
    },
    "actTwo": {
      "risingAction": "...",
      "midpoint": "...",
      "complications": "...",
      "plotPoint2": "..."
    },
    "actThree": {
      "climax": "...",
      "resolution": "...",
      "newEquilibrium": "..."
    }
  },
  "keyScenes": [
    {
      "sceneNumber": 1,
      "title": "...",
      "description": "...",
      "purpose": "...",
      "emotionalBeat": "..."
    }
  ],
  "thematicElements": ["..."],
  "uniqueSellingPoints": ["..."]
}
\`\`\`

**Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ù‡Ù…Ø©:**
- ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„ÙÙƒØ±Ø© Ø£ØµÙ„ÙŠØ© ÙˆÙ…Ø¨ØªÙƒØ±Ø©
- Ø§Ø­ØªØ±Ù… Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø£Ø¯Ø¨ÙŠ ÙˆØ§Ù„Ø¬Ù…Ù‡ÙˆØ± Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù
- ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ ØµØ±Ø§Ø¹ ÙˆØ§Ø¶Ø­ ÙˆÙ…Ù‚Ù†Ø¹
- Ø§Ø¬Ø¹Ù„ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠØ© Ù‚ÙˆÙŠØ© ÙˆÙ…Ø­ÙƒÙ…Ø©
`;
  }

  /**
   * Build prompt for character development
   */
  private buildCharacterPrompt(brief: any, storyStructure: any): string {
    return `
# Ù…Ù‡Ù…Ø©: ØªØ·ÙˆÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù‚ØµØµÙŠØ©

## Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù‚ØµØµÙŠØ©:
**Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:** ${storyStructure.title}
**Ø§Ù„Ù…Ù„Ø®Øµ:** ${storyStructure.synopsis}

## Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ù…Ù† Ø§Ù„Ù…ÙˆØ¬Ø²:
${JSON.stringify(brief.mainCharacters, null, 2)}

## Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:
Ù‚Ù… Ø¨ØªØ·ÙˆÙŠØ± ÙƒÙ„ Ø´Ø®ØµÙŠØ© Ø¨Ø´ÙƒÙ„ Ø¹Ù…ÙŠÙ‚ ÙˆÙ…ÙØµÙ„ØŒ Ù…ØªØ¶Ù…Ù†Ø§Ù‹:

1. **Ø§Ù„Ø§Ø³Ù… ÙˆØ§Ù„Ø¯ÙˆØ±**
2. **Ø§Ù„ÙˆØµÙ Ø§Ù„Ù…ÙØµÙ„:** Ø§Ù„Ù…Ø¸Ù‡Ø±ØŒ Ø§Ù„Ø´Ø®ØµÙŠØ©ØŒ Ø§Ù„Ø®Ù„ÙÙŠØ©
3. **Ø§Ù„Ù‚ÙˆØ³ Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠ:** ÙƒÙŠÙ ØªØªØºÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ© Ø®Ù„Ø§Ù„ Ø§Ù„Ù‚ØµØ©
4. **Ø§Ù„Ø¯Ø§ÙØ¹:** Ù…Ø§ Ø§Ù„Ø°ÙŠ ÙŠØ­Ø±Ùƒ Ø§Ù„Ø´Ø®ØµÙŠØ©
5. **Ø§Ù„ØµØ±Ø§Ø¹:** Ø§Ù„ØµØ±Ø§Ø¹ Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ ÙˆØ§Ù„Ø®Ø§Ø±Ø¬ÙŠ

**ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©:**
Ø§Ø³ØªØ®Ø¯Ù… JSON Ø¨Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„ØªØ§Ù„ÙŠ:
\`\`\`json
[
  {
    "name": "...",
    "role": "...",
    "description": "...",
    "arc": "...",
    "motivation": "...",
    "conflict": "..."
  }
]
\`\`\`

**Ù…Ù„Ø§Ø­Ø¸Ø§Øª:**
- ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† ÙƒÙ„ Ø´Ø®ØµÙŠØ© Ù…Ø¹Ù‚Ø¯Ø© ÙˆÙˆØ§Ù‚Ø¹ÙŠØ©
- ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª ØªØ®Ø¯Ù… Ø§Ù„Ù‚ØµØ©
- Ø§Ø¬Ø¹Ù„ Ø¯ÙˆØ§ÙØ¹ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª ÙˆØ§Ø¶Ø­Ø© ÙˆÙ…Ù‚Ù†Ø¹Ø©
`;
  }

  /**
   * Parse story structure from AI response
   */
  private parseStoryStructure(content: string): any {
    try {
      // Extract JSON from markdown code blocks if present
      const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/);
      const jsonContent = jsonMatch ? jsonMatch[1] : content;

      const parsed = JSON.parse(jsonContent);

      return {
        title: parsed.title || 'Ù‚ØµØ© Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†',
        logline: parsed.logline || '',
        synopsis: parsed.synopsis || '',
        threeActStructure: parsed.threeActStructure || {},
        keyScenes: parsed.keyScenes || [],
        thematicElements: parsed.thematicElements || [],
        uniqueSellingPoints: parsed.uniqueSellingPoints || [],
      };
    } catch (error) {
      logger.error('Failed to parse story structure', {
        error: error instanceof Error ? error.message : String(error),
        content: content.substring(0, 500),
      });
      throw new ServiceError('Failed to parse story structure', 500);
    }
  }

  /**
   * Parse characters from AI response
   */
  private parseCharacters(content: string): Character[] {
    try {
      // Extract JSON from markdown code blocks if present
      const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/);
      const jsonContent = jsonMatch ? jsonMatch[1] : content;

      const parsed = JSON.parse(jsonContent);

      if (!Array.isArray(parsed)) {
        throw new Error('Expected array of characters');
      }

      return parsed.map((char) => ({
        name: char.name || 'Ø´Ø®ØµÙŠØ© Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…',
        role: char.role || '',
        description: char.description || '',
        arc: char.arc,
        motivation: char.motivation,
        conflict: char.conflict,
      }));
    } catch (error) {
      logger.error('Failed to parse characters', {
        error: error instanceof Error ? error.message : String(error),
        content: content.substring(0, 500),
      });
      throw new ServiceError('Failed to parse characters', 500);
    }
  }

  /**
   * Get all ideas for a session
   */
  async getSessionIdeas(sessionId: string): Promise<Idea[]> {
    try {
      const ideas = await this.prisma.idea.findMany({
        where: { sessionId },
        orderBy: { ideaNumber: 'asc' },
      });

      return ideas.map((idea) => ({
        id: idea.id,
        sessionId: idea.sessionId,
        ideaNumber: idea.ideaNumber as 1 | 2,
        title: idea.title,
        logline: idea.logline,
        synopsis: idea.synopsis,
        threeActStructure: idea.threeActStructure as ThreeActStructure,
        mainCharacters: idea.mainCharacters as Character[],
        keyScenes: idea.keyScenes as KeyScene[],
        thematicElements: idea.thematicElements as string[],
        uniqueSellingPoints: idea.uniqueSellingPoints as string[],
        generatedBy: idea.generatedByAgents as any,
        metadata: idea.generationMetadata as any,
      }));
    } catch (error) {
      logger.error('Failed to get session ideas', {
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to get session ideas', 500);
    }
  }
}

## ğŸ“ **4. Review Engine Service**

### `src/services/review-engine.service.ts`

```typescript
// src/services/review-engine.service.ts

import { PrismaClient } from '@prisma/client';
import { AgentType, ReviewOutput } from '@/types/agent.types';
import { AgentManagerService } from './agent-manager.service';
import { logger } from '@/utils/logger';
import { ServiceError } from '@/utils/errors';

interface ReviewScores {
  quality: number;
  novelty: number;
  impact: number;
}

export class ReviewEngineService {
  private prisma: PrismaClient;
  private agentManager: AgentManagerService;

  constructor(prisma: PrismaClient, agentManager: AgentManagerService) {
    this.prisma = prisma;
    this.agentManager = agentManager;
  }

  /**
   * Conduct independent reviews by all 11 agents for both ideas
   */
  async conductAllReviews(
    sessionId: string,
    apiKey: string
  ): Promise<ReviewOutput[]> {
    const startTime = Date.now();

    try {
      logger.info('Starting review process', { sessionId });

      // Get both ideas
      const ideas = await this.prisma.idea.findMany({
        where: { sessionId },
        orderBy: { ideaNumber: 'asc' },
      });

      if (ideas.length !== 2) {
        throw new ServiceError(
          `Expected 2 ideas, found ${ideas.length}`,
          400
        );
      }

      // Get all agents
      const agents = await this.agentManager.getSessionAgents(sessionId);

      if (agents.length !== 11) {
        throw new ServiceError(
          `Expected 11 agents, found ${agents.length}`,
          400
        );
      }

      // Conduct reviews in parallel (all agents review all ideas simultaneously)
      const reviewPromises: Promise<ReviewOutput>[] = [];

      for (const agent of agents) {
        for (const idea of ideas) {
          reviewPromises.push(
            this.conductSingleReview(agent.id, idea.id, apiKey, sessionId)
          );
        }
      }

      const reviews = await Promise.all(reviewPromises);

      logger.info('Review process completed', {
        sessionId,
        reviewCount: reviews.length,
        duration: Date.now() - startTime,
      });

      return reviews;
    } catch (error) {
      logger.error('Failed to conduct reviews', {
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Conduct a single review by one agent for one idea
   */
  private async conductSingleReview(
    agentId: string,
    ideaId: string,
    apiKey: string,
    sessionId: string
  ): Promise<ReviewOutput> {
    const startTime = Date.now();

    try {
      logger.info('Conducting single review', { agentId, ideaId });

      // Get agent details
      const agent = await this.prisma.agent.findUnique({
        where: { id: agentId },
      });

      if (!agent) {
        throw new ServiceError('Agent not found', 404);
      }

      // Get idea details
      const idea = await this.prisma.idea.findUnique({
        where: { id: ideaId },
      });

      if (!idea) {
        throw new ServiceError('Idea not found', 404);
      }

      // Build review prompt based on agent specialty
      const prompt = this.buildReviewPrompt(
        agent.agentType as AgentType,
        idea
      );

      // Execute agent
      const response = await this.agentManager.executeAgent(
        agentId,
        prompt,
        apiKey
      );

      // Parse review from response
      const reviewData = this.parseReviewResponse(response.content);

      // Save review to database
      const savedReview = await this.prisma.review.create({
        data: {
          sessionId,
          agentId,
          ideaId,
          qualityScore: reviewData.scores.quality,
          noveltyScore: reviewData.scores.novelty,
          impactScore: reviewData.scores.impact,
          qualityAnalysis: reviewData.analysis.quality,
          noveltyAnalysis: reviewData.analysis.novelty,
          impactAnalysis: reviewData.analysis.impact,
          strengths: reviewData.strengths,
          weaknesses: reviewData.weaknesses,
          recommendations: reviewData.recommendations,
          overallVerdict: reviewData.overallVerdict,
          reviewMetadata: {
            responseTime: Date.now() - startTime,
            tokensUsed: response.metadata.tokensUsed,
          },
        },
      });

      logger.info('Single review completed', {
        reviewId: savedReview.id,
        agentId,
        ideaId,
        duration: Date.now() - startTime,
      });

      return {
        agentId,
        agentType: agent.agentType as AgentType,
        ideaId,
        scores: reviewData.scores,
        analysis: reviewData.analysis,
        strengths: reviewData.strengths,
        weaknesses: reviewData.weaknesses,
        recommendations: reviewData.recommendations,
        overallVerdict: reviewData.overallVerdict,
      };
    } catch (error) {
      logger.error('Failed to conduct single review', {
        agentId,
        ideaId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Build review prompt based on agent type
   */
  private buildReviewPrompt(agentType: AgentType, idea: any): string {
    const basePrompt = `
# Ù…Ù‡Ù…Ø© Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ù…Ø³ØªÙ‚Ù„Ø©

## Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡Ø§:

**Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:** ${idea.title}

**Ø§Ù„Ù„ÙˆØ¬Ù„Ø§ÙŠÙ†:** ${idea.logline}

**Ø§Ù„Ù…Ù„Ø®Øµ:**
${idea.synopsis}

**Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø«Ù„Ø§Ø«ÙŠØ©:**
${JSON.stringify(idea.threeActStructure, null, 2)}

**Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:**
${JSON.stringify(idea.mainCharacters, null, 2)}

**Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:**
${JSON.stringify(idea.keyScenes, null, 2)}

**Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ÙŠØ©:**
${idea.thematicElements.join(', ')}

---

## ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©:

Ø¨ØµÙØªÙƒ **${this.getAgentRoleName(agentType)}**ØŒ Ù‚Ù… Ø¨ØªÙ‚ÙŠÙŠÙ… Ù‡Ø°Ù‡ Ø§Ù„ÙÙƒØ±Ø© Ù…Ù† Ù…Ù†Ø¸ÙˆØ±Ùƒ Ø§Ù„Ù…ØªØ®ØµØµ.

### Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„ØªÙ‚ÙŠÙŠÙ…:

1. **Ø§Ù„Ø¬ÙˆØ¯Ø© (Quality Score: 0-10):**
   ${this.getQualityCriteria(agentType)}

2. **Ø§Ù„Ø¬Ø¯Ø© (Novelty Score: 0-10):**
   ${this.getNoveltyCriteria(agentType)}

3. **Ø§Ù„ØªØ£Ø«ÙŠØ± (Impact Score: 0-10):**
   ${this.getImpactCriteria(agentType)}

### Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:

Ù‚Ø¯Ù… ØªØ­Ù„ÙŠÙ„Ø§Ù‹ Ù…ÙØµÙ„Ø§Ù‹ ÙˆÙ…ÙˆØ¶ÙˆØ¹ÙŠØ§Ù‹ ÙŠØªØ¶Ù…Ù†:

- **ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¬ÙˆØ¯Ø©:** ØªÙ‚ÙŠÙŠÙ… Ø¹Ù…ÙŠÙ‚ Ù„Ø¬ÙˆØ¯Ø© Ø§Ù„ÙÙƒØ±Ø© Ù…Ù† Ù…Ù†Ø¸ÙˆØ±Ùƒ
- **ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¬Ø¯Ø©:** Ù…Ø¯Ù‰ Ø£ØµØ§Ù„Ø© ÙˆØªÙ…ÙŠØ² Ø§Ù„ÙÙƒØ±Ø©
- **ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ£Ø«ÙŠØ±:** Ø§Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„Ù…Ø­ØªÙ…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù…Ù‡ÙˆØ± ÙˆØ§Ù„Ø³ÙˆÙ‚
- **Ù†Ù‚Ø§Ø· Ø§Ù„Ù‚ÙˆØ©:** 3-5 Ù†Ù‚Ø§Ø· Ù‚ÙˆØ© Ù…Ø­Ø¯Ø¯Ø©
- **Ù†Ù‚Ø§Ø· Ø§Ù„Ø¶Ø¹Ù:** 3-5 Ù†Ù‚Ø§Ø· Ø¶Ø¹Ù Ø£Ùˆ ØªØ­Ø¯ÙŠØ§Øª
- **Ø§Ù„ØªÙˆØµÙŠØ§Øª:** 3-5 ØªÙˆØµÙŠØ§Øª Ù„Ù„ØªØ­Ø³ÙŠÙ†
- **Ø§Ù„Ø­ÙƒÙ… Ø§Ù„Ø¹Ø§Ù…:** ØªÙ‚ÙŠÙŠÙ… Ø´Ø§Ù…Ù„ ÙˆÙ†Ù‡Ø§Ø¦ÙŠ

**ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© (JSON ÙÙ‚Ø·):**
\`\`\`json
{
  "scores": {
    "quality": 8.5,
    "novelty": 7.0,
    "impact": 9.0
  },
  "analysis": {
    "quality": "ØªØ­Ù„ÙŠÙ„ Ù…ÙØµÙ„ Ù„Ù„Ø¬ÙˆØ¯Ø©...",
    "novelty": "ØªØ­Ù„ÙŠÙ„ Ù…ÙØµÙ„ Ù„Ù„Ø¬Ø¯Ø©...",
    "impact": "ØªØ­Ù„ÙŠÙ„ Ù…ÙØµÙ„ Ù„Ù„ØªØ£Ø«ÙŠØ±..."
  },
  "strengths": [
    "Ù†Ù‚Ø·Ø© Ù‚ÙˆØ© 1",
    "Ù†Ù‚Ø·Ø© Ù‚ÙˆØ© 2",
    "Ù†Ù‚Ø·Ø© Ù‚ÙˆØ© 3"
  ],
  "weaknesses": [
    "Ù†Ù‚Ø·Ø© Ø¶Ø¹Ù 1",
    "Ù†Ù‚Ø·Ø© Ø¶Ø¹Ù 2",
    "Ù†Ù‚Ø·Ø© Ø¶Ø¹Ù 3"
  ],
  "recommendations": [
    "ØªÙˆØµÙŠØ© 1",
    "ØªÙˆØµÙŠØ© 2",
    "ØªÙˆØµÙŠØ© 3"
  ],
  "overallVerdict": "Ø­ÙƒÙ… Ø´Ø§Ù…Ù„ ÙˆÙ†Ù‡Ø§Ø¦ÙŠ Ø¹Ù„Ù‰ Ø§Ù„ÙÙƒØ±Ø©..."
}
\`\`\`

**Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ù‡Ù…Ø©:**
- ÙƒÙ† Ù…ÙˆØ¶ÙˆØ¹ÙŠØ§Ù‹ ÙˆØµØ§Ø¯Ù‚Ø§Ù‹ ÙÙŠ ØªÙ‚ÙŠÙŠÙ…Ùƒ
- Ø§Ø³ØªØ®Ø¯Ù… Ø®Ø¨Ø±ØªÙƒ Ø§Ù„Ù…ØªØ®ØµØµØ© ÙÙŠ Ù…Ø¬Ø§Ù„Ùƒ ÙÙ‚Ø·
- Ù‚Ø¯Ù… ØªÙ‚ÙŠÙŠÙ…Ø§Ù‹ Ù…Ø³ØªÙ‚Ù„Ø§Ù‹ Ø¨Ø¯ÙˆÙ† ØªØ­ÙŠØ²
- Ø±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© Ù„Ù…Ø¬Ø§Ù„ ØªØ®ØµØµÙƒ
`;

    return basePrompt;
  }

  /**
   * Get agent role name in Arabic
   */
  private getAgentRoleName(agentType: AgentType): string {
    const roleNames: Record<AgentType, string> = {
      [AgentType.STORY_ARCHITECT]: 'Ù…Ù‡Ù†Ø¯Ø³ Ø§Ù„Ù‚ØµØ©',
      [AgentType.REALISM_CRITIC]: 'Ù†Ø§Ù‚Ø¯ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©',
      [AgentType.STRATEGIC_ANALYST]: 'Ø§Ù„Ù…Ø­Ù„Ù„ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ',
      [AgentType.CHARACTER_DEVELOPMENT]: 'Ø®Ø¨ÙŠØ± ØªØ·ÙˆÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª',
      [AgentType.CHARACTER_EXPANSION]: 'Ø®Ø¨ÙŠØ± ØªÙˆØ³ÙŠØ¹ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª',
      [AgentType.WORLD_BUILDING]: 'Ø®Ø¨ÙŠØ± Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù„Ù…',
      [AgentType.DIALOGUE_VOICE]: 'Ø®Ø¨ÙŠØ± Ø§Ù„Ø­ÙˆØ§Ø± ÙˆØ§Ù„ØµÙˆØª',
      [AgentType.THEME]: 'Ø®Ø¨ÙŠØ± Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹',
      [AgentType.GENRE_TONE]: 'Ø®Ø¨ÙŠØ± Ø§Ù„Ù†ÙˆØ¹ ÙˆØ§Ù„Ù†Ø¨Ø±Ø©',
      [AgentType.PACING]: 'Ø®Ø¨ÙŠØ± Ø§Ù„Ø³Ø±Ø¹Ø© ÙˆØ§Ù„Ø¥ÙŠÙ‚Ø§Ø¹',
      [AgentType.CONFLICT_TENSION]: 'Ø®Ø¨ÙŠØ± Ø§Ù„ØµØ±Ø§Ø¹ ÙˆØ§Ù„ØªÙˆØªØ±',
    };

    return roleNames[agentType];
  }

  /**
   * Get quality criteria based on agent type
   */
  private getQualityCriteria(agentType: AgentType): string {
    const criteria: Record<AgentType, string> = {
      [AgentType.STORY_ARCHITECT]:
        'Ù‚ÙˆØ© Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø³Ø±Ø¯ÙŠØ©ØŒ ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø­Ø¨ÙƒØ©ØŒ ÙØ¹Ø§Ù„ÙŠØ© Ù†Ù‚Ø§Ø· Ø§Ù„ØªØ­ÙˆÙ„ Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠØ©',
      [AgentType.REALISM_CRITIC]:
        'ÙˆØ§Ù‚Ø¹ÙŠØ© Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ÙˆØ§Ù„Ø´Ø®ØµÙŠØ§ØªØŒ Ù…Ù†Ø·Ù‚ÙŠØ© Ø§Ù„Ø³Ø¨Ø¨ÙŠØ©ØŒ Ø£ØµØ§Ù„Ø© Ø§Ù„ØªÙØ§ØµÙŠÙ„',
      [AgentType.STRATEGIC_ANALYST]:
        'Ø§Ù„Ø¬Ø¯ÙˆÙ‰ Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©ØŒ Ø¬Ø§Ø°Ø¨ÙŠØ© Ø§Ù„Ø³ÙˆÙ‚ØŒ Ø¥Ù…ÙƒØ§Ù†Ø§Øª Ø§Ù„Ù†Ø¬Ø§Ø­ Ø§Ù„ØªØ¬Ø§Ø±ÙŠ',
      [AgentType.CHARACTER_DEVELOPMENT]:
        'Ø¹Ù…Ù‚ Ø§Ù„Ø´Ø®ØµÙŠØ§ØªØŒ ØªØ¹Ù‚ÙŠØ¯ Ø§Ù„Ø¯ÙˆØ§ÙØ¹ØŒ ÙˆØ§Ù‚Ø¹ÙŠØ© Ø§Ù„Ù‚ÙˆØ³ Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠ',
      [AgentType.CHARACTER_EXPANSION]:
        'Ø«Ø±Ø§Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¨ÙŠØ¦ÙŠ Ù„Ù„Ø´Ø®ØµÙŠØ§ØªØŒ ØªÙ†ÙˆØ¹ Ø§Ù„Ø£Ø¯ÙˆØ§Ø±ØŒ Ø¹Ù…Ù‚ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø«Ø§Ù†ÙˆÙŠØ©',
      [AgentType.WORLD_BUILDING]:
        'ØºÙ†Ù‰ Ø§Ù„Ø¹Ø§Ù„Ù…ØŒ Ø§ØªØ³Ø§Ù‚ Ø§Ù„ØªÙØ§ØµÙŠÙ„ØŒ Ø¹Ù…Ù‚ Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„Ø«Ù‚Ø§ÙÙŠ ÙˆØ§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ',
      [AgentType.DIALOGUE_VOICE]:
        'Ø£ØµØ§Ù„Ø© Ø§Ù„Ø­ÙˆØ§Ø±ØŒ ØªÙ…ÙŠØ² Ø§Ù„Ø£ØµÙˆØ§ØªØŒ ÙØ¹Ø§Ù„ÙŠØ© Ø§Ù„Ù†Øµ Ø§Ù„Ø­ÙˆØ§Ø±ÙŠ',
      [AgentType.THEME]:
        'Ø¹Ù…Ù‚ Ø§Ù„Ù…ÙˆØ§Ø¶ÙŠØ¹ØŒ ÙˆØ¶ÙˆØ­ Ø§Ù„Ø±Ø³Ø§Ù„Ø©ØŒ Ù‚ÙˆØ© Ø§Ù„Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„ÙÙ„Ø³ÙÙŠ',
      [AgentType.GENRE_TONE]:
        'Ø§ØªØ³Ø§Ù‚ Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø£Ø¯Ø¨ÙŠØŒ Ù…Ù„Ø§Ø¡Ù…Ø© Ø§Ù„Ù†Ø¨Ø±Ø©ØŒ ÙØ¹Ø§Ù„ÙŠØ© Ø§Ù„Ø¬Ùˆ Ø§Ù„Ø¹Ø§Ù…',
      [AgentType.PACING]:
        'Ø¥ÙŠÙ‚Ø§Ø¹ Ø§Ù„Ø³Ø±Ø¯ØŒ ØªÙˆØ²ÙŠØ¹ Ø§Ù„ØªÙˆØªØ±ØŒ ÙØ¹Ø§Ù„ÙŠØ© Ø§Ù„Ø²Ø®Ù… Ø§Ù„Ù‚ØµØµÙŠ',
      [AgentType.CONFLICT_TENSION]:
        'Ù‚ÙˆØ© Ø§Ù„ØµØ±Ø§Ø¹ØŒ ÙØ¹Ø§Ù„ÙŠØ© Ø§Ù„ØªÙˆØªØ±ØŒ ÙˆØ¶ÙˆØ­ Ø§Ù„Ù…Ø®Ø§Ø·Ø±',
    };

    return criteria[agentType];
  }

  /**
   * Get novelty criteria based on agent type
   */
  private getNoveltyCriteria(agentType: AgentType): string {
    return 'Ø§Ù„Ø£ØµØ§Ù„Ø© ÙˆØ§Ù„ØªÙ…ÙŠØ² Ø¶Ù…Ù† Ù…Ø¬Ø§Ù„ ØªØ®ØµØµÙƒØŒ Ø§Ù„Ø§Ø¨ØªÙƒØ§Ø± ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©ØŒ Ø§Ù„ØªÙØ±Ø¯ Ø¹Ù† Ø§Ù„Ø£Ø¹Ù…Ø§Ù„ Ø§Ù„Ù…Ø´Ø§Ø¨Ù‡Ø©';
  }

  /**
   * Get impact criteria based on agent type
   */
  private getImpactCriteria(agentType: AgentType): string {
    return 'Ø§Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„Ù…Ø­ØªÙ…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù…Ù‡ÙˆØ±ØŒ Ø§Ù„Ù‚Ø¯Ø±Ø© Ø¹Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø« ØµØ¯Ù‰ Ø¹Ø§Ø·ÙÙŠØŒ Ø¥Ù…ÙƒØ§Ù†Ø§Øª Ø§Ù„Ù†Ø¬Ø§Ø­ ÙˆØ§Ù„Ø§Ù†ØªØ´Ø§Ø±';
  }

  /**
   * Parse review response from AI
   */
  private parseReviewResponse(content: string): {
    scores: ReviewScores;
    analysis: {
      quality: string;
      novelty: string;
      impact: string;
    };
    strengths: string[];
    weaknesses: string[];
    recommendations: string[];
    overallVerdict: string;
  } {
    try {
      // Extract JSON from markdown code blocks
      const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/);
      const jsonContent = jsonMatch ? jsonMatch[1] : content;

      const parsed = JSON.parse(jsonContent);

      // Validate scores are within range
      const validateScore = (score: number): number => {
        return Math.max(0, Math.min(10, score));
      };

      return {
        scores: {
          quality: validateScore(parsed.scores?.quality || 5),
          novelty: validateScore(parsed.scores?.novelty || 5),
          impact: validateScore(parsed.scores?.impact || 5),
        },
        analysis: {
          quality: parsed.analysis?.quality || 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØ­Ù„ÙŠÙ„',
          novelty: parsed.analysis?.novelty || 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØ­Ù„ÙŠÙ„',
          impact: parsed.analysis?.impact || 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØ­Ù„ÙŠÙ„',
        },
        strengths: Array.isArray(parsed.strengths)
          ? parsed.strengths
          : [],
        weaknesses: Array.isArray(parsed.weaknesses)
          ? parsed.weaknesses
          : [],
        recommendations: Array.isArray(parsed.recommendations)
          ? parsed.recommendations
          : [],
        overallVerdict: parsed.overallVerdict || 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­ÙƒÙ…',
      };
    } catch (error) {
      logger.error('Failed to parse review response', {
        error: error instanceof Error ? error.message : String(error),
        content: content.substring(0, 500),
      });
      throw new ServiceError('Failed to parse review response', 500);
    }
  }

  /**
   * Get all reviews for a session
   */
  async getSessionReviews(sessionId: string): Promise<ReviewOutput[]> {
    try {
      const reviews = await this.prisma.review.findMany({
        where: { sessionId },
        include: {
          agent: {
            select: {
              id: true,
              agentType: true,
              agentName: true,
            },
          },
        },
      });

      return reviews.map((review) => ({
        agentId: review.agentId,
        agentType: review.agent.agentType as AgentType,
        ideaId: review.ideaId,
        scores: {
          quality: review.qualityScore,
          novelty: review.noveltyScore,
          impact: review.impactScore,
        },
        analysis: {
          quality: review.qualityAnalysis,
          novelty: review.noveltyAnalysis,
          impact: review.impactAnalysis,
        },
        strengths: review.strengths as string[],
        weaknesses: review.weaknesses as string[],
        recommendations: review.recommendations as string[],
        overallVerdict: review.overallVerdict,
      }));
    } catch (error) {
      logger.error('Failed to get session reviews', {
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to get session reviews', 500);
    }
  }

  /**
   * Get reviews aggregated by idea
   */
  async getReviewsByIdea(ideaId: string): Promise<ReviewOutput[]> {
    try {
      const reviews = await this.prisma.review.findMany({
        where: { ideaId },
        include: {
          agent: {
            select: {
              id: true,
              agentType: true,
              agentName: true,
            },
          },
        },
      });

      return reviews.map((review) => ({
        agentId: review.agentId,
        agentType: review.agent.agentType as AgentType,
        ideaId: review.ideaId,
        scores: {
          quality: review.qualityScore,
          novelty: review.noveltyScore,
          impact: review.impactScore,
        },
        analysis: {
          quality: review.qualityAnalysis,
          novelty: review.noveltyAnalysis,
          impact: review.impactAnalysis,
        },
        strengths: review.strengths as string[],
        weaknesses: review.weaknesses as string[],
        recommendations: review.recommendations as string[],
        overallVerdict: review.overallVerdict,
      }));
    } catch (error) {
      logger.error('Failed to get reviews by idea', {
        ideaId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to get reviews by idea', 500);
    }
  }

  /**
   * Calculate average scores for an idea
   */
  async getIdeaAverageScores(ideaId: string): Promise<ReviewScores> {
    try {
      const reviews = await this.prisma.review.findMany({
        where: { ideaId },
        select: {
          qualityScore: true,
          noveltyScore: true,
          impactScore: true,
        },
      });

      if (reviews.length === 0) {
        return { quality: 0, novelty: 0, impact: 0 };
      }

      const sum = reviews.reduce(
        (acc, review) => ({
          quality: acc.quality + review.qualityScore,
          novelty: acc.novelty + review.noveltyScore,
          impact: acc.impact + review.impactScore,
        }),
        { quality: 0, novelty: 0, impact: 0 }
      );

      return {
        quality: Number((sum.quality / reviews.length).toFixed(2)),
        novelty: Number((sum.novelty / reviews.length).toFixed(2)),
        impact: Number((sum.impact / reviews.length).toFixed(2)),
      };
    } catch (error) {
      logger.error('Failed to calculate average scores', {
        ideaId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to calculate average scores', 500);
    }
  }
}
```

---

## ğŸ“ **5. Tournament Manager Service**

### `src/services/tournament-manager.service.ts`

```typescript
// src/services/tournament-manager.service.ts

import { PrismaClient, Tournament } from '@prisma/client';
import {
  TournamentStatus,
  TournamentData,
  TournamentTurn,
  TournamentArgument,
  TournamentProgress,
} from '@/types/tournament.types';
import { AgentType } from '@/types/agent.types';
import { AgentManagerService } from './agent-manager.service';
import { logger } from '@/utils/logger';
import { ServiceError } from '@/utils/errors';

export class TournamentManagerService {
  private prisma: PrismaClient;
  private agentManager: AgentManagerService;
  private readonly MAX_TURNS = 8;
  private readonly AGENTS_PER_TURN = 2;

  constructor(prisma: PrismaClient, agentManager: AgentManagerService) {
    this.prisma = prisma;
    this.agentManager = agentManager;
  }

  /**
   * Conduct the tournament discussion
   */
  async conductTournament(
    sessionId: string,
    apiKey: string
  ): Promise<Tournament> {
    const startTime = Date.now();

    try {
      logger.info('Starting tournament', { sessionId });

      // Get both ideas
      const ideas = await this.prisma.idea.findMany({
        where: { sessionId },
        orderBy: { ideaNumber: 'asc' },
      });

      if (ideas.length !== 2) {
        throw new ServiceError('Need exactly 2 ideas for tournament', 400);
      }

      // Get all reviews
      const reviews = await this.prisma.review.findMany({
        where: { sessionId },
        include: {
          agent: true,
        },
      });

      // Create tournament record
      const tournament = await this.prisma.tournament.create({
        data: {
          sessionId,
          status: TournamentStatus.ACTIVE,
          currentTurn: 0,
          maxTurns: this.MAX_TURNS,
          tournamentData: {
            idea1Id: ideas[0].id,
            idea2Id: ideas[1].id,
            reviews: reviews.map((r) => ({
              agentId: r.agentId,
              agentType: r.agent.agentType,
              ideaId: r.ideaId,
              scores: {
                quality: r.qualityScore,
                novelty: r.noveltyScore,
                impact: r.impactScore,
              },
            })),
          },
        },
      });

      // Conduct tournament turns
      const turns: TournamentTurn[] = [];

      for (let turnNumber = 1; turnNumber <= this.MAX_TURNS; turnNumber++) {
        logger.info('Conducting tournament turn', {
          sessionId,
          turnNumber,
        });

        const turn = await this.conductTurn(
          tournament.id,
          turnNumber,
          ideas,
          reviews,
          apiKey,
          turns
        );

        turns.push(turn);

        // Save turn to database
        await this.prisma.tournamentTurn.create({
          data: {
            tournamentId: tournament.id,
            turnNumber,
            participatingAgents: turn.participatingAgents,
            arguments: turn.arguments as any,
            turnMetadata: {
              summary: turn.summary,
              shiftInMomentum: turn.shiftInMomentum,
            },
          },
        });

        // Update tournament current turn
        await this.prisma.tournament.update({
          where: { id: tournament.id },
          data: { currentTurn: turnNumber },
        });
      }

      // Mark tournament as completed
      await this.prisma.tournament.update({
        where: { id: tournament.id },
        data: {
          status: TournamentStatus.COMPLETED,
          endedAt: new Date(),
          tournamentData: {
            ...(tournament.tournamentData as any),
            turns,
          },
        },
      });

      logger.info('Tournament completed', {
        sessionId,
        tournamentId: tournament.id,
        duration: Date.now() - startTime,
      });

      return tournament;
    } catch (error) {
      logger.error('Failed to conduct tournament', {
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Conduct a single tournament turn
   */
  private async conductTurn(
    tournamentId: string,
    turnNumber: number,
    ideas: any[],
    reviews: any[],
    apiKey: string,
    previousTurns: TournamentTurn[]
  ): Promise<TournamentTurn> {
    try {
      // Select agents for this turn (rotate through all agents)
      const agents = await this.agentManager.getSessionAgents(
        ideas[0].sessionId
      );

      const startIndex = ((turnNumber - 1) * this.AGENTS_PER_TURN) % agents.length;
      const participatingAgents = [
        agents[startIndex],
        agents[(startIndex + 1) % agents.length],
      ];

      // Collect arguments from participating agents
      const arguments: TournamentArgument[] = [];

      for (const agent of participatingAgents) {
        const prompt = this.buildTournamentPrompt(
          agent.type,
          ideas,
          reviews,
          previousTurns,
          turnNumber
        );

        const response = await this.agentManager.executeAgent(
          agent.id,
          prompt,
          apiKey
        );

        const argument = this.parseArgumentResponse(response.content, agent);
        arguments.push(argument);
      }

      // Generate turn summary
      const summary = this.generateTurnSummary(arguments, turnNumber);

      // Calculate momentum shift
      const shiftInMomentum = this.calculateMomentumShift(
        arguments,
        previousTurns
      );

      return {
        turnNumber,
        participatingAgents: participatingAgents.map((a) => ({
          agentId: a.id,
          agentType: a.type,
          agentName: a.name,
        })),
        arguments,
        summary,
        shiftInMomentum,
      };
    } catch (error) {
      logger.error('Failed to conduct turn', {
        tournamentId,
        turnNumber,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Build tournament prompt for an agent
   */
  private buildTournamentPrompt(
    agentType: AgentType,
    ideas: any[],
    reviews: any[],
    previousTurns: TournamentTurn[],
    currentTurn: number
  ): string {
    const idea1Reviews = reviews.filter((r) => r.ideaId === ideas[0].id);
    const idea2Reviews = reviews.filter((r) => r.ideaId === ideas[1].id);

    return `
# Ø¬Ù„Ø³Ø© Ø§Ù„Ù†Ù‚Ø§Ø´ Ø§Ù„ØªÙ†Ø§ÙØ³ÙŠ - Ø§Ù„Ø¯ÙˆØ± ${currentTurn}

## Ø§Ù„Ø³ÙŠØ§Ù‚:
Ø£Ù†Øª ØªØ´Ø§Ø±Ùƒ ÙÙŠ Ø¬Ù„Ø³Ø© Ù†Ù‚Ø§Ø´ ØªÙ†Ø§ÙØ³ÙŠØ© Ù„Ø§Ø®ØªÙŠØ§Ø± Ø£ÙØ¶Ù„ ÙÙƒØ±Ø© Ù‚ØµØµÙŠØ© Ù…Ù† Ø¨ÙŠÙ† ÙÙƒØ±ØªÙŠÙ†.

## Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰:
**Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:** ${ideas[0].title}
**Ø§Ù„Ù„ÙˆØ¬Ù„Ø§ÙŠÙ†:** ${ideas[0].logline}
**Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª:**
- Ø§Ù„Ø¬ÙˆØ¯Ø©: ${this.calculateAverageScore(idea1Reviews, 'qualityScore')}
- Ø§Ù„Ø¬Ø¯Ø©: ${this.calculateAverageScore(idea1Reviews, 'noveltyScore')}
- Ø§Ù„ØªØ£Ø«ÙŠØ±: ${this.calculateAverageScore(idea1Reviews, 'impactScore')}

## Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©:
**Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:** ${ideas[1].title}
**Ø§Ù„Ù„ÙˆØ¬Ù„Ø§ÙŠÙ†:** ${ideas[1].logline}
**Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª:**
- Ø§Ù„Ø¬ÙˆØ¯Ø©: ${this.calculateAverageScore(idea2Reviews, 'qualityScore')}
- Ø§Ù„Ø¬Ø¯Ø©: ${this.calculateAverageScore(idea2Reviews, 'noveltyScore')}
- Ø§Ù„ØªØ£Ø«ÙŠØ±: ${this.calculateAverageScore(idea2Reviews, 'impactScore')}

${previousTurns.length > 0 ? this.formatPreviousTurns(previousTurns) : ''}

---

## Ù…Ù‡Ù…ØªÙƒ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø¯ÙˆØ±:

Ø¨ØµÙØªÙƒ **${this.getAgentRoleName(agentType)}**ØŒ Ù‚Ø¯Ù… Ø­Ø¬ØªÙƒ ÙÙŠ Ø§Ù„Ù†Ù‚Ø§Ø´:

1. **Ø§Ø®ØªØ± Ù…ÙˆÙ‚ÙÙƒ:**
   - Ù‡Ù„ ØªØ¯Ø¹Ù… Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ Ø£Ù… Ø§Ù„Ø«Ø§Ù†ÙŠØ©ØŸ
   - Ø£Ù… Ù„Ø¯ÙŠÙƒ Ù…ÙˆÙ‚Ù Ù…Ø­Ø§ÙŠØ¯ØŸ

2. **Ù‚Ø¯Ù… Ø­Ø¬ØªÙƒ:**
   - Ø¯Ø§ÙØ¹ Ø¹Ù† Ù†Ù‚Ø§Ø· Ø§Ù„Ù‚ÙˆØ© ÙÙŠ Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„ØªÙŠ ØªØ¯Ø¹Ù…Ù‡Ø§
   - Ø§Ù†ØªÙ‚Ø¯ Ù†Ù‚Ø§Ø· Ø§Ù„Ø¶Ø¹Ù ÙÙŠ Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£Ø®Ø±Ù‰
   - Ø§Ø³ØªØ®Ø¯Ù… Ø®Ø¨Ø±ØªÙƒ Ø§Ù„Ù…ØªØ®ØµØµØ© ÙÙŠ Ù…Ø¬Ø§Ù„Ùƒ
   - Ø§Ø³ØªÙ†Ø¯ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø§Øª ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©

3. **Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© (Ø¥Ù† ÙˆØ¬Ø¯Øª):**
   - ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ø§Ù„Ø­Ø¬Ø¬ Ø§Ù„Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø£Ø¯ÙˆØ§Ø± Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
   - Ù‚Ø¯Ù… ÙˆØ¬Ù‡Ø© Ù†Ø¸Ø± Ø¬Ø¯ÙŠØ¯Ø© Ø£Ùˆ Ù…Ø®ØªÙ„ÙØ©

**ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© (JSON ÙÙ‚Ø·):**
\`\`\`json
{
  "position": "supporting_idea_1" | "supporting_idea_2" | "neutral",
  "argument": "Ø­Ø¬ØªÙƒ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„Ù…ÙØµÙ„Ø©...",
  "keyPoints": [
    "Ù†Ù‚Ø·Ø© Ø±Ø¦ÙŠØ³ÙŠØ© 1",
    "Ù†Ù‚Ø·Ø© Ø±Ø¦ÙŠØ³ÙŠØ© 2",
    "Ù†Ù‚Ø·Ø© Ø±Ø¦ÙŠØ³ÙŠØ© 3"
  ],
  "rebuttal": "Ø±Ø¯Ùƒ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø¬Ø¬ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© (Ø¥Ù† ÙˆØ¬Ø¯Øª)..."
}
\`\`\`

**Ù…Ù„Ø§Ø­Ø¸Ø§Øª:**
- ÙƒÙ† Ù…ÙˆØ¶ÙˆØ¹ÙŠØ§Ù‹ ÙˆØµØ§Ø¯Ù‚Ø§Ù‹
- Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø¯Ù„Ø© Ù…Ù† Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø§Øª
- Ø±ÙƒØ² Ø¹Ù„Ù‰ Ù…Ø¬Ø§Ù„ ØªØ®ØµØµÙƒ
- Ù‚Ø¯Ù… ØªØ­Ù„ÙŠÙ„Ø§Ù‹ Ù…Ø¹Ù…Ù‚Ø§Ù‹ ÙˆÙ„ÙŠØ³ Ø³Ø·Ø­ÙŠØ§Ù‹
`;
  }

  /**
   * Parse argument response from AI
   */
  private parseArgumentResponse(
    content: string,
    agent: any
  ): TournamentArgument {
    try {
      const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/);
      const jsonContent = jsonMatch ? jsonMatch[1] : content;
      const parsed = JSON.parse(jsonContent);

      return {
        agentId: agent.id,
        agentType: agent.type,
        agentName: agent.name,
        position: parsed.position || 'neutral',
        argument: parsed.argument || '',
        keyPoints: Array.isArray(parsed.keyPoints) ? parsed.keyPoints : [],
        rebuttal: parsed.rebuttal,
        timestamp: new Date(),
      };
    } catch (error) {
      logger.error('Failed to parse argument response', {
        error: error instanceof Error ? error.message : String(error),
        content: content.substring(0, 500),
      });

      // Return a default argument if parsing fails
      return {
        agentId: agent.id,
        agentType: agent.type,
        agentName: agent.name,
        position: 'neutral',
        argument: 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©',
        keyPoints: [],
        timestamp: new Date(),
      };
    }
  }

  /**
   * Generate summary for a turn
   */
  private generateTurnSummary(
    arguments: TournamentArgument[],
    turnNumber: number
  ): string {
    const idea1Support = arguments.filter(
      (a) => a.position === 'supporting_idea_1'
    ).length;
    const idea2Support = arguments.filter(
      (a) => a.position === 'supporting_idea_2'
    ).length;
    const neutral = arguments.filter((a) => a.position === 'neutral').length;

    return `Ø§Ù„Ø¯ÙˆØ± ${turnNumber}: Ø´Ø§Ø±Ùƒ ${arguments.length} Ù…Ù† Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡. Ø¯Ø¹Ù… Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰: ${idea1Support}ØŒ Ø¯Ø¹Ù… Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: ${idea2Support}ØŒ Ù…Ø­Ø§ÙŠØ¯: ${neutral}.`;
  }

  /**
   * Calculate momentum shift between turns
   */
  private calculateMomentumShift(
    currentArguments: TournamentArgument[],
    previousTurns: TournamentTurn[]
  ): {
    before: { idea1Support: number; idea2Support: number };
    after: { idea1Support: number; idea2Support: number };
  } | undefined {
    if (previousTurns.length === 0) {
      return undefined;
    }

    const lastTurn = previousTurns[previousTurns.length - 1];

    const beforeIdea1 = lastTurn.arguments.filter(
      (a: any) => a.position === 'supporting_idea_1'
    ).length;
    const beforeIdea2 = lastTurn.arguments.filter(
      (a: any) => a.position === 'supporting_idea_2'
    ).length;

    const afterIdea1 = currentArguments.filter(
      (a) => a.position === 'supporting_idea_1'
    ).length;
    const afterIdea2 = currentArguments.filter(
      (a) => a.position === 'supporting_idea_2'
    ).length;

    return {
      before: {
        idea1Support: beforeIdea1,
        idea2Support: beforeIdea2,
      },
      after: {
        idea1Support: afterIdea1,
        idea2Support: afterIdea2,
      },
    };
  }

  /**
   * Helper methods
   */
  private calculateAverageScore(reviews: any[], field: string): string {
    if (reviews.length === 0) return '0.0';
    const sum = reviews.reduce((acc, r) => acc + r[field], 0);
    return (sum / reviews.length).toFixed(1);
  }

  private getAgentRoleName(agentType: AgentType): string {
    const roleNames: Record<AgentType, string> = {
      [AgentType.STORY_ARCHITECT]: 'Ù…Ù‡Ù†Ø¯Ø³ Ø§Ù„Ù‚ØµØ©',
      [AgentType.REALISM_CRITIC]: 'Ù†Ø§Ù‚Ø¯ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©',
      [AgentType.STRATEGIC_ANALYST]: 'Ø§Ù„Ù…Ø­Ù„Ù„ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ',
      [AgentType.CHARACTER_DEVELOPMENT]: 'Ø®Ø¨ÙŠØ± ØªØ·ÙˆÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª',
      [AgentType.CHARACTER_EXPANSION]: 'Ø®Ø¨ÙŠØ± ØªÙˆØ³ÙŠØ¹ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª',
      [AgentType.WORLD_BUILDING]: 'Ø®Ø¨ÙŠØ± Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù„Ù…',
      [AgentType.DIALOGUE_VOICE]: 'Ø®Ø¨ÙŠØ± Ø§Ù„Ø­ÙˆØ§Ø± ÙˆØ§Ù„ØµÙˆØª',
      [AgentType.THEME]: 'Ø®Ø¨ÙŠØ± Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹',
      [AgentType.GENRE_TONE]: 'Ø®Ø¨ÙŠØ± Ø§Ù„Ù†ÙˆØ¹ ÙˆØ§Ù„Ù†Ø¨Ø±Ø©',
      [AgentType.PACING]: 'Ø®Ø¨ÙŠØ± Ø§Ù„Ø³Ø±Ø¹Ø© ÙˆØ§Ù„Ø¥ÙŠÙ‚Ø§Ø¹',
      [AgentType.CONFLICT_TENSION]: 'Ø®Ø¨ÙŠØ± Ø§Ù„ØµØ±Ø§Ø¹ ÙˆØ§Ù„ØªÙˆØªØ±',
    };
    return roleNames[agentType];
  }

  private formatPreviousTurns(turns: TournamentTurn[]): string {
    let formatted = '\n## Ø§Ù„Ø£Ø¯ÙˆØ§Ø± Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©:\n\n';

    for (const turn of turns) {
      formatted += `### Ø§Ù„Ø¯ÙˆØ± ${turn.turnNumber}:\n`;
      formatted += `${turn.summary}\n\n`;

      for (const arg of turn.arguments) {
        formatted += `**${arg.agentName}** (${arg.position}):\n`;
        formatted += `${arg.argument.substring(0, 200)}...\n\n`;
      }
    }

    return formatted;
  }

  /**
   * Get tournament progress
   */
  async getTournamentProgress(
    tournamentId: string
  ): Promise<TournamentProgress> {
    try {
      const tournament = await this.prisma.tournament.findUnique({
        where: { id: tournamentId },
        include: {
          turns: {
            orderBy: { turnNumber: 'asc' },
          },
        },
      });

      if (!tournament) {
        throw new ServiceError('Tournament not found', 404);
      }

      // Count support across all turns
      let idea1Support = 0;
      let idea2Support = 0;
      let neutralAgents = 0;

      for (const turn of tournament.turns) {
        const turnArgs = (turn.arguments as any[]) || [];
        idea1Support += turnArgs.filter(
          (a: any) => a.position === 'supporting_idea_1'
        ).length;
        idea2Support += turnArgs.filter(
          (a: any) => a.position === 'supporting_idea_2'
        ).length;
        neutralAgents += turnArgs.filter(
          (a: any) => a.position === 'neutral'
        ).length;
      }

      return {
        tournamentId: tournament.id,
        status: tournament.status as TournamentStatus,
        currentTurn: tournament.currentTurn,
        maxTurns: tournament.maxTurns,
        idea1Support,
        idea2Support,
        neutralAgents,
      };
    } catch (error) {
      logger.error('Failed to get tournament progress', {
        tournamentId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }
}

Ø£ØªØ§Ø¨Ø¹ Ù…Ø¹Ùƒ Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙƒÙˆØ¯:

---

## ğŸ“ **6. Decision Maker Service**

### `src/services/decision-maker.service.ts`

```typescript
// src/services/decision-maker.service.ts

import { PrismaClient, FinalDecision } from '@prisma/client';
import { AgentType } from '@/types/agent.types';
import { AgentManagerService } from './agent-manager.service';
import { logger } from '@/utils/logger';
import { ServiceError } from '@/utils/errors';

interface DecisionData {
  winningIdeaId: string;
  losingIdeaId: string;
  rationale: string;
  keyStrengths: string[];
  addressedWeaknesses: string[];
  voteBreakdown: {
    idea1Votes: number;
    idea2Votes: number;
    neutralVotes: number;
    unanimous: boolean;
  };
  confidenceScore: number;
  implementationRecommendations: string[];
  nextSteps: string[];
}

export class DecisionMakerService {
  private prisma: PrismaClient;
  private agentManager: AgentManagerService;

  constructor(prisma: PrismaClient, agentManager: AgentManagerService) {
    this.prisma = prisma;
    this.agentManager = agentManager;
  }

  /**
   * Make final decision after tournament
   */
  async makeFinalDecision(
    sessionId: string,
    apiKey: string
  ): Promise<FinalDecision> {
    const startTime = Date.now();

    try {
      logger.info('Making final decision', { sessionId });

      // Get tournament
      const tournament = await this.prisma.tournament.findUnique({
        where: { sessionId },
        include: {
          turns: {
            orderBy: { turnNumber: 'asc' },
          },
        },
      });

      if (!tournament) {
        throw new ServiceError('Tournament not found', 404);
      }

      // Get both ideas
      const ideas = await this.prisma.idea.findMany({
        where: { sessionId },
        orderBy: { ideaNumber: 'asc' },
      });

      if (ideas.length !== 2) {
        throw new ServiceError('Need exactly 2 ideas for decision', 400);
      }

      // Get all reviews
      const reviews = await this.prisma.review.findMany({
        where: { sessionId },
        include: {
          agent: true,
        },
      });

      // Analyze tournament results
      const tournamentAnalysis = this.analyzeTournament(tournament);

      // Build decision prompt
      const prompt = this.buildDecisionPrompt(
        ideas,
        reviews,
        tournament,
        tournamentAnalysis
      );

      // Execute master orchestrator decision
      const agents = await this.agentManager.getSessionAgents(sessionId);
      const orchestratorAgent = agents[0]; // Use first agent as orchestrator

      const response = await this.agentManager.executeAgent(
        orchestratorAgent.id,
        prompt,
        apiKey
      );

      // Parse decision
      const decisionData = this.parseDecisionResponse(response.content, ideas);

      // Save decision to database
      const decision = await this.prisma.finalDecision.create({
        data: {
          sessionId,
          tournamentId: tournament.id,
          winningIdeaId: decisionData.winningIdeaId,
          losingIdeaId: decisionData.losingIdeaId,
          decisionRationale: decisionData.rationale,
          keyStrengths: decisionData.keyStrengths,
          addressedWeaknesses: decisionData.addressedWeaknesses,
          voteBreakdown: decisionData.voteBreakdown as any,
          unanimous: decisionData.voteBreakdown.unanimous,
          confidenceScore: decisionData.confidenceScore,
          implementationRecommendations: decisionData.implementationRecommendations,
          nextSteps: decisionData.nextSteps,
          decisionMetadata: {
            decisionTime: Date.now() - startTime,
            tournamentTurns: tournament.currentTurn,
            totalReviews: reviews.length,
          },
        },
      });

      logger.info('Final decision made', {
        sessionId,
        decisionId: decision.id,
        winningIdeaId: decision.winningIdeaId,
        duration: Date.now() - startTime,
      });

      return decision;
    } catch (error) {
      logger.error('Failed to make final decision', {
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Analyze tournament results
   */
  private analyzeTournament(tournament: any): {
    idea1TotalSupport: number;
    idea2TotalSupport: number;
    neutralTotal: number;
    turnsCompleted: number;
    keyMoments: string[];
  } {
    let idea1Support = 0;
    let idea2Support = 0;
    let neutral = 0;
    const keyMoments: string[] = [];

    for (const turn of tournament.turns) {
      const args = (turn.arguments as any[]) || [];

      const turnIdea1 = args.filter(
        (a: any) => a.position === 'supporting_idea_1'
      ).length;
      const turnIdea2 = args.filter(
        (a: any) => a.position === 'supporting_idea_2'
      ).length;
      const turnNeutral = args.filter(
        (a: any) => a.position === 'neutral'
      ).length;

      idea1Support += turnIdea1;
      idea2Support += turnIdea2;
      neutral += turnNeutral;

      // Identify key moments (significant shifts)
      if (Math.abs(turnIdea1 - turnIdea2) >= 2) {
        keyMoments.push(
          `Ø§Ù„Ø¯ÙˆØ± ${turn.turnNumber}: ØªØ­ÙˆÙ„ ÙƒØ¨ÙŠØ± ÙÙŠ Ø§Ù„Ø²Ø®Ù… (${turnIdea1} Ù…Ù‚Ø§Ø¨Ù„ ${turnIdea2})`
        );
      }
    }

    return {
      idea1TotalSupport: idea1Support,
      idea2TotalSupport: idea2Support,
      neutralTotal: neutral,
      turnsCompleted: tournament.currentTurn,
      keyMoments,
    };
  }

  /**
   * Build decision prompt
   */
  private buildDecisionPrompt(
    ideas: any[],
    reviews: any[],
    tournament: any,
    analysis: any
  ): string {
    return `
# Ø§Ù„Ù‚Ø±Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ - Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„ÙØ§Ø¦Ø²Ø©

## Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„ÙƒØ§Ù…Ù„:

### Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰:
**Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:** ${ideas[0].title}
**Ø§Ù„Ù„ÙˆØ¬Ù„Ø§ÙŠÙ†:** ${ideas[0].logline}
**Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª:**
${this.formatReviewScores(reviews, ideas[0].id)}

### Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©:
**Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:** ${ideas[1].title}
**Ø§Ù„Ù„ÙˆØ¬Ù„Ø§ÙŠÙ†:** ${ideas[1].logline}
**Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª:**
${this.formatReviewScores(reviews, ideas[1].id)}

---

## Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø·ÙˆÙ„Ø©:
- **Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¯ÙˆØ§Ø± Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©:** ${analysis.turnsCompleted}
- **Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù„Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰:** ${analysis.idea1TotalSupport}
- **Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù„Ù„ÙÙƒØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©:** ${analysis.idea2TotalSupport}
- **Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙŠØ¯ÙˆÙ†:** ${analysis.neutralTotal}

### Ø§Ù„Ù„Ø­Ø¸Ø§Øª Ø§Ù„Ù…ÙØµÙ„ÙŠØ©:
${analysis.keyMoments.map((m: string) => `- ${m}`).join('\n')}

---

## Ù…Ù‡Ù…ØªÙƒ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:

Ø¨ØµÙØªÙƒ **Ø§Ù„Ù…Ù†Ø¸Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ (Master Orchestrator)**ØŒ Ù‚Ù… Ø¨Ø§ØªØ®Ø§Ø° Ø§Ù„Ù‚Ø±Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ ÙˆØ¥Ø¹Ù„Ø§Ù† Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„ÙØ§Ø¦Ø²Ø©.

### Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:

1. **Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„ÙØ§Ø¦Ø²Ø©:** Ø­Ø¯Ø¯ Ø£ÙŠ ÙÙƒØ±Ø© ÙØ§Ø²Øª (1 Ø£Ùˆ 2)

2. **Ø§Ù„Ù…Ø¨Ø±Ø± Ø§Ù„Ø´Ø§Ù…Ù„:** Ø§Ø´Ø±Ø­ Ø¨Ø§Ù„ØªÙØµÙŠÙ„ Ø³Ø¨Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ù‡Ø°Ù‡ Ø§Ù„ÙÙƒØ±Ø©:
   - Ø§Ø³ØªÙ†Ø¯ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ø§Ù„Ù…Ø³ØªÙ‚Ù„Ø©
   - Ø§Ø³ØªØ´Ù‡Ø¯ Ø¨Ø§Ù„Ø­Ø¬Ø¬ Ø§Ù„Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø¨Ø·ÙˆÙ„Ø©
   - ÙˆØ¶Ø­ Ø§Ù„Ø£Ø³Ø¨Ø§Ø¨ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ÙŠØ© Ù„Ù„Ù‚Ø±Ø§Ø±

3. **Ù†Ù‚Ø§Ø· Ø§Ù„Ù‚ÙˆØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:** Ø­Ø¯Ø¯ 5-7 Ù†Ù‚Ø§Ø· Ù‚ÙˆØ© Ø±Ø¦ÙŠØ³ÙŠØ© ÙÙŠ Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„ÙØ§Ø¦Ø²Ø©

4. **Ù…Ø¹Ø§Ù„Ø¬Ø© Ù†Ù‚Ø§Ø· Ø§Ù„Ø¶Ø¹Ù:** Ø§Ø°ÙƒØ± 3-5 Ù†Ù‚Ø§Ø· Ø¶Ø¹Ù ØªÙ… ØªØ­Ø¯ÙŠØ¯Ù‡Ø§ ÙˆÙƒÙŠÙ ÙŠÙ…ÙƒÙ† Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡Ø§

5. **Ø§Ù„ØªÙˆØµÙŠØ§Øª Ø§Ù„ØªÙ†ÙÙŠØ°ÙŠØ©:** Ù‚Ø¯Ù… 5-8 ØªÙˆØµÙŠØ§Øª Ø¹Ù…Ù„ÙŠØ© Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„ÙÙƒØ±Ø©

6. **Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:** Ø­Ø¯Ø¯ 5-7 Ø®Ø·ÙˆØ§Øª Ù…Ù„Ù…ÙˆØ³Ø© Ù„Ù„Ø¨Ø¯Ø¡ ÙÙŠ ØªØ·ÙˆÙŠØ± Ø§Ù„Ù…Ø´Ø±ÙˆØ¹

**ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© (JSON ÙÙ‚Ø·):**
\`\`\`json
{
  "winningIdea": 1 | 2,
  "rationale": "Ø§Ù„Ù…Ø¨Ø±Ø± Ø§Ù„Ø´Ø§Ù…Ù„ Ø§Ù„Ù…ÙØµÙ„...",
  "keyStrengths": [
    "Ù†Ù‚Ø·Ø© Ù‚ÙˆØ© 1",
    "Ù†Ù‚Ø·Ø© Ù‚ÙˆØ© 2",
    "..."
  ],
  "addressedWeaknesses": [
    {
      "weakness": "Ù†Ù‚Ø·Ø© Ø§Ù„Ø¶Ø¹Ù",
      "solution": "ÙƒÙŠÙÙŠØ© Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡Ø§"
    }
  ],
  "confidenceScore": 8.5,
  "implementationRecommendations": [
    "ØªÙˆØµÙŠØ© 1",
    "ØªÙˆØµÙŠØ© 2",
    "..."
  ],
  "nextSteps": [
    "Ø®Ø·ÙˆØ© 1",
    "Ø®Ø·ÙˆØ© 2",
    "..."
  ]
}
\`\`\`

**Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ù‡Ù…Ø©:**
- ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù‚Ø±Ø§Ø± Ù…ÙˆØ¶ÙˆØ¹ÙŠØ§Ù‹ ÙˆÙ…Ø¯Ø¹ÙˆÙ…Ø§Ù‹ Ø¨Ø§Ù„Ø£Ø¯Ù„Ø©
- Ø«Ù‚ØªÙƒ (confidenceScore) ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù…Ù† 0-10
- Ù‚Ø¯Ù… ØªØ­Ù„ÙŠÙ„Ø§Ù‹ Ø´Ø§Ù…Ù„Ø§Ù‹ ÙˆÙ„ÙŠØ³ Ø³Ø·Ø­ÙŠØ§Ù‹
- Ø§Ø¬Ø¹Ù„ Ø§Ù„ØªÙˆØµÙŠØ§Øª ÙˆØ§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© Ø¹Ù…Ù„ÙŠØ© ÙˆÙ‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ†ÙÙŠØ°
`;
  }

  /**
   * Parse decision response
   */
  private parseDecisionResponse(
    content: string,
    ideas: any[]
  ): DecisionData {
    try {
      const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/);
      const jsonContent = jsonMatch ? jsonMatch[1] : content;
      const parsed = JSON.parse(jsonContent);

      const winningIdeaNumber = parsed.winningIdea;
      const winningIdea = ideas.find(
        (i) => i.ideaNumber === winningIdeaNumber
      );
      const losingIdea = ideas.find(
        (i) => i.ideaNumber !== winningIdeaNumber
      );

      if (!winningIdea || !losingIdea) {
        throw new Error('Could not determine winning/losing ideas');
      }

      // Process addressed weaknesses
      const addressedWeaknesses = Array.isArray(parsed.addressedWeaknesses)
        ? parsed.addressedWeaknesses.map((w: any) =>
            typeof w === 'string' ? w : `${w.weakness}: ${w.solution}`
          )
        : [];

      return {
        winningIdeaId: winningIdea.id,
        losingIdeaId: losingIdea.id,
        rationale: parsed.rationale || 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¨Ø±Ø±',
        keyStrengths: Array.isArray(parsed.keyStrengths)
          ? parsed.keyStrengths
          : [],
        addressedWeaknesses,
        voteBreakdown: {
          idea1Votes: winningIdeaNumber === 1 ? 1 : 0,
          idea2Votes: winningIdeaNumber === 2 ? 1 : 0,
          neutralVotes: 0,
          unanimous: true, // Since it's master orchestrator's final decision
        },
        confidenceScore: Math.max(
          0,
          Math.min(10, parsed.confidenceScore || 7)
        ),
        implementationRecommendations: Array.isArray(
          parsed.implementationRecommendations
        )
          ? parsed.implementationRecommendations
          : [],
        nextSteps: Array.isArray(parsed.nextSteps) ? parsed.nextSteps : [],
      };
    } catch (error) {
      logger.error('Failed to parse decision response', {
        error: error instanceof Error ? error.message : String(error),
        content: content.substring(0, 500),
      });
      throw new ServiceError('Failed to parse decision response', 500);
    }
  }

  /**
   * Format review scores for display
   */
  private formatReviewScores(reviews: any[], ideaId: string): string {
    const ideaReviews = reviews.filter((r) => r.ideaId === ideaId);

    if (ideaReviews.length === 0) {
      return 'Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ‚ÙŠÙŠÙ…Ø§Øª';
    }

    const avgQuality =
      ideaReviews.reduce((sum, r) => sum + r.qualityScore, 0) /
      ideaReviews.length;
    const avgNovelty =
      ideaReviews.reduce((sum, r) => sum + r.noveltyScore, 0) /
      ideaReviews.length;
    const avgImpact =
      ideaReviews.reduce((sum, r) => sum + r.impactScore, 0) /
      ideaReviews.length;

    return `
- Ø§Ù„Ø¬ÙˆØ¯Ø©: ${avgQuality.toFixed(1)}/10
- Ø§Ù„Ø¬Ø¯Ø©: ${avgNovelty.toFixed(1)}/10
- Ø§Ù„ØªØ£Ø«ÙŠØ±: ${avgImpact.toFixed(1)}/10
`;
  }

  /**
   * Get final decision for a session
   */
  async getSessionDecision(sessionId: string): Promise<FinalDecision | null> {
    try {
      return await this.prisma.finalDecision.findUnique({
        where: { sessionId },
        include: {
          winningIdea: true,
          losingIdea: true,
          tournament: true,
        },
      });
    } catch (error) {
      logger.error('Failed to get session decision', {
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw new ServiceError('Failed to get session decision', 500);
    }
  }
}
```

---

## ğŸ“ **7. API Routes**

### `src/api/routes/auth.routes.ts`

```typescript
// src/api/routes/auth.routes.ts

import { FastifyInstance } from 'fastify';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';
import {
  registerSchema,
  loginSchema,
  apiKeySchema,
  RegisterInput,
  LoginInput,
  ApiKeyInput,
} from '@/schemas/auth.schema';
import { validateRequest } from '@/api/middlewares/validate.middleware';
import { authenticate } from '@/api/middlewares/auth.middleware';
import { generateToken, generateRefreshToken } from '@/utils/jwt';
import { encryptApiKey } from '@/utils/encryption';
import { logger } from '@/utils/logger';
import { ServiceError } from '@/utils/errors';

export async function authRoutes(
  fastify: FastifyInstance,
  prisma: PrismaClient
) {
  /**
   * POST /auth/register - Register new user
   */
  fastify.post(
    '/register',
    {
      preHandler: validateRequest(registerSchema),
    },
    async (request, reply) => {
      const { email, password, fullName } = request.body as RegisterInput;

      try {
        // Check if user already exists
        const existingUser = await prisma.user.findUnique({
          where: { email },
        });

        if (existingUser) {
          return reply.status(409).send({
            error: 'User already exists',
            message: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„',
          });
        }

        // Hash password
        const hashedPassword = await bcrypt.hash(password, 12);

        // Create user
        const user = await prisma.user.create({
          data: {
            email,
            hashedPassword,
            fullName,
            isActive: true,
            isVerified: false,
          },
          select: {
            id: true,
            email: true,
            fullName: true,
            createdAt: true,
          },
        });

        logger.info('User registered', { userId: user.id, email: user.email });

        // Generate tokens
        const accessToken = generateToken({ userId: user.id, email: user.email });
        const refreshToken = generateRefreshToken({ userId: user.id });

        return reply.status(201).send({
          user,
          accessToken,
          refreshToken,
        });
      } catch (error) {
        logger.error('Registration failed', {
          email,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Registration failed',
          message: 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨',
        });
      }
    }
  );

  /**
   * POST /auth/login - User login
   */
  fastify.post(
    '/login',
    {
      preHandler: validateRequest(loginSchema),
    },
    async (request, reply) => {
      const { email, password } = request.body as LoginInput;

      try {
        // Find user
        const user = await prisma.user.findUnique({
          where: { email },
        });

        if (!user || !user.isActive) {
          return reply.status(401).send({
            error: 'Invalid credentials',
            message: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©',
          });
        }

        // Verify password
        const isValidPassword = await bcrypt.compare(
          password,
          user.hashedPassword
        );

        if (!isValidPassword) {
          return reply.status(401).send({
            error: 'Invalid credentials',
            message: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©',
          });
        }

        // Update last login
        await prisma.user.update({
          where: { id: user.id },
          data: { lastLogin: new Date() },
        });

        logger.info('User logged in', { userId: user.id, email: user.email });

        // Generate tokens
        const accessToken = generateToken({ userId: user.id, email: user.email });
        const refreshToken = generateRefreshToken({ userId: user.id });

        return reply.send({
          user: {
            id: user.id,
            email: user.email,
            fullName: user.fullName,
            isVerified: user.isVerified,
          },
          accessToken,
          refreshToken,
        });
      } catch (error) {
        logger.error('Login failed', {
          email,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Login failed',
          message: 'ÙØ´Ù„ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„',
        });
      }
    }
  );

  /**
   * POST /auth/api-keys - Add Gemini API key
   */
  fastify.post(
    '/api-keys',
    {
      preHandler: [authenticate, validateRequest(apiKeySchema)],
    },
    async (request, reply) => {
      const { geminiApiKey, keyName, quotaLimit } = request.body as ApiKeyInput;
      const userId = (request as any).user.userId;

      try {
        // Encrypt API key
        const encryptedKey = encryptApiKey(geminiApiKey);

        // Save to database
        const apiKey = await prisma.apiKey.create({
          data: {
            userId,
            encryptedKey,
            keyName: keyName || 'Gemini API Key',
            quotaLimit,
            isActive: true,
          },
          select: {
            id: true,
            keyName: true,
            quotaLimit: true,
            quotaUsed: true,
            createdAt: true,
            isActive: true,
          },
        });

        logger.info('API key added', { userId, apiKeyId: apiKey.id });

        return reply.status(201).send({
          apiKey,
          message: 'ØªÙ… Ø¥Ø¶Ø§ÙØ© Ù…ÙØªØ§Ø­ API Ø¨Ù†Ø¬Ø§Ø­',
        });
      } catch (error) {
        logger.error('Failed to add API key', {
          userId,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Failed to add API key',
          message: 'ÙØ´Ù„ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ù…ÙØªØ§Ø­ API',
        });
      }
    }
  );

  /**
   * GET /auth/api-keys - Get user's API keys
   */
  fastify.get(
    '/api-keys',
    {
      preHandler: authenticate,
    },
    async (request, reply) => {
      const userId = (request as any).user.userId;

      try {
        const apiKeys = await prisma.apiKey.findMany({
          where: { userId, isActive: true },
          select: {
            id: true,
            keyName: true,
            quotaLimit: true,
            quotaUsed: true,
            lastUsedAt: true,
            createdAt: true,
            isActive: true,
          },
          orderBy: { createdAt: 'desc' },
        });

        return reply.send({ apiKeys });
      } catch (error) {
        logger.error('Failed to get API keys', {
          userId,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Failed to get API keys',
        });
      }
    }
  );

  /**
   * DELETE /auth/api-keys/:id - Delete API key
   */
  fastify.delete(
    '/api-keys/:id',
    {
      preHandler: authenticate,
    },
    async (request, reply) => {
      const { id } = request.params as { id: string };
      const userId = (request as any).user.userId;

      try {
        // Verify ownership
        const apiKey = await prisma.apiKey.findUnique({
          where: { id },
          select: { userId: true },
        });

        if (!apiKey || apiKey.userId !== userId) {
          return reply.status(404).send({
            error: 'API key not found',
          });
        }

        // Soft delete
        await prisma.apiKey.update({
          where: { id },
          data: { isActive: false },
        });

        logger.info('API key deleted', { userId, apiKeyId: id });

        return reply.send({
          message: 'ØªÙ… Ø­Ø°Ù Ù…ÙØªØ§Ø­ API Ø¨Ù†Ø¬Ø§Ø­',
        });
      } catch (error) {
        logger.error('Failed to delete API key', {
          userId,
          apiKeyId: id,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Failed to delete API key',
        });
      }
    }
  );

  /**
   * GET /auth/me - Get current user
   */
  fastify.get(
    '/me',
    {
      preHandler: authenticate,
    },
    async (request, reply) => {
      const userId = (request as any).user.userId;

      try {
        const user = await prisma.user.findUnique({
          where: { id: userId },
          select: {
            id: true,
            email: true,
            fullName: true,
            isVerified: true,
            createdAt: true,
            lastLogin: true,
          },
        });

        if (!user) {
          return reply.status(404).send({
            error: 'User not found',
          });
        }

        return reply.send({ user });
      } catch (error) {
        logger.error('Failed to get user', {
          userId,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Failed to get user',
        });
      }
    }
  );
}
```

---

### `src/api/routes/session.routes.ts`

```typescript
// src/api/routes/session.routes.ts

import { FastifyInstance } from 'fastify';
import { PrismaClient } from '@prisma/client';
import {
  createSessionSchema,
  creativeBriefSchema,
  CreateSessionInput,
  CreativeBriefInput,
} from '@/schemas/session.schema';
import { validateRequest } from '@/api/middlewares/validate.middleware';
import { authenticate } from '@/api/middlewares/auth.middleware';
import { SessionService } from '@/services/session.service';
import { OrchestratorService } from '@/services/orchestrator.service';
import { decryptApiKey } from '@/utils/encryption';
import { logger } from '@/utils/logger';

export async function sessionRoutes(
  fastify: FastifyInstance,
  prisma: PrismaClient
) {
  const sessionService = new SessionService(prisma);

  /**
   * POST /sessions - Create new session
   */
  fastify.post(
    '/',
    {
      preHandler: [authenticate, validateRequest(createSessionSchema)],
    },
    async (request, reply) => {
      const { apiKeyId } = request.body as CreateSessionInput;
      const userId = (request as any).user.userId;

      try {
        // Verify API key ownership
        const apiKey = await prisma.apiKey.findUnique({
          where: { id: apiKeyId },
        });

        if (!apiKey || apiKey.userId !== userId || !apiKey.isActive) {
          return reply.status(400).send({
            error: 'Invalid API key',
            message: 'Ù…ÙØªØ§Ø­ API ØºÙŠØ± ØµØ§Ù„Ø­',
          });
        }

        // Create session
        const session = await sessionService.createSession(userId, apiKeyId);

        logger.info('Session created', {
          sessionId: session.id,
          userId,
        });

        return reply.status(201).send({
          session: {
            id: session.id,
            status: session.status,
            currentPhase: session.currentPhase,
            createdAt: session.createdAt,
          },
        });
      } catch (error) {
        logger.error('Failed to create session', {
          userId,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Failed to create session',
          message: 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø©',
        });
      }
    }
  );

  /**
   * GET /sessions - Get user sessions
   */
  fastify.get(
    '/',
    {
      preHandler: authenticate,
    },
    async (request, reply) => {
      const userId = (request as any).user.userId;
      const { limit = 20, offset = 0 } = request.query as any;

      try {
        const { sessions, total } = await sessionService.getUserSessions(
          userId,
          Number(limit),
          Number(offset)
        );

        return reply.send({
          sessions: sessions.map((s) => ({
            id: s.id,
            status: s.status,
            currentPhase: s.currentPhase,
            createdAt: s.createdAt,
            completedAt: s.completedAt,
            brief: s.creativeBrief
              ? {
                  coreIdea: s.creativeBrief.coreIdea.substring(0, 100),
                  genre: s.creativeBrief.genre,
                }
              : null,
            winningIdea: s.finalDecision?.winningIdea
              ? {
                  title: s.finalDecision.winningIdea.title,
                }
              : null,
          })),
          total,
          limit: Number(limit),
          offset: Number(offset),
        });
      } catch (error) {
        logger.error('Failed to get sessions', {
          userId,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Failed to get sessions',
        });
      }
    }
  );

  /**
   * GET /sessions/:id - Get session details
   */
  fastify.get(
    '/:id',
    {
      preHandler: authenticate,
    },
    async (request, reply) => {
      const { id } = request.params as { id: string };
      const userId = (request as any).user.userId;

      try {
        const session = await sessionService.getSessionById(id);

        if (!session) {
          return reply.status(404).send({
            error: 'Session not found',
          });
        }

        // Verify ownership
        if (session.userId !== userId) {
          return reply.status(403).send({
            error: 'Unauthorized',
          });
        }

        return reply.send({ session });
      } catch (error) {
        logger.error('Failed to get session', {
          sessionId: id,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Failed to get session',
        });
      }
    }
  );

  /**
   * POST /sessions/:id/brief - Submit creative brief
   */
  fastify.post(
    '/:id/brief',
    {
      preHandler: [authenticate, validateRequest(creativeBriefSchema)],
    },
    async (request, reply) => {
      const { id } = request.params as { id: string };
      const brief = request.body as CreativeBriefInput;
      const userId = (request as any).user.userId;

      try {
        const session = await sessionService.getSessionById(id);

        if (!session || session.userId !== userId) {
          return reply.status(404).send({
            error: 'Session not found',
          });
        }

        // Submit brief
        await sessionService.submitCreativeBrief(id, brief);

        logger.info('Creative brief submitted', {
          sessionId: id,
          userId,
        });

        return reply.send({
          message: 'ØªÙ… ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ù…ÙˆØ¬Ø² Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹ÙŠ Ø¨Ù†Ø¬Ø§Ø­',
        });
      } catch (error) {
        logger.error('Failed to submit brief', {
          sessionId: id,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Failed to submit brief',
          message: 'ÙØ´Ù„ ÙÙŠ ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ù…ÙˆØ¬Ø²',
        });
      }
    }
  );

  /**
   * POST /sessions/:id/start - Start narrative development process
   */
  fastify.post(
    '/:id/start',
    {
      preHandler: authenticate,
    },
    async (request, reply) => {
      const { id } = request.params as { id: string };
      const userId = (request as any).user.userId;

      try {
        const session = await sessionService.getSessionById(id);

        if (!session || session.userId !== userId) {
          return reply.status(404).send({
            error: 'Session not found',
          });
        }

        // Get decrypted API key
        const apiKeyRecord = await prisma.apiKey.findUnique({
          where: { id: session.apiKeyId },
        });

        if (!apiKeyRecord) {
          return reply.status(400).send({
            error: 'API key not found',
          });
        }

        const apiKey = decryptApiKey(apiKeyRecord.encryptedKey);

        // Start orchestrator process (async)
        const orchestrator = new OrchestratorService(prisma, {
          sessionId: id,
          userId,
          apiKey,
        });

        // Start process in background
        orchestrator.startProcess().catch((error) => {
          logger.error('Orchestrator process failed', {
            sessionId: id,
            error: error instanceof Error ? error.message : String(error),
          });
        });

        logger.info('Narrative development process started', {
          sessionId: id,
          userId,
        });

        return reply.send({
          message: 'Ø¨Ø¯Ø£Øª Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„Ø³Ø±Ø¯ÙŠ',
          sessionId: id,
        });
      } catch (error) {
        logger.error('Failed to start process', {
          sessionId: id,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Failed to start process',
          message: 'ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©',
        });
      }
    }
  );

  /**
   * DELETE /sessions/:id - Delete session
   */
  fastify.delete(
    '/:id',
    {
      preHandler: authenticate,
    },
    async (request, reply) => {
      const { id } = request.params as { id: string };
      const userId = (request as any).user.userId;

      try {
        await sessionService.deleteSession(id, userId);

        logger.info('Session deleted', { sessionId: id, userId });

        return reply.send({
          message: 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¬Ù„Ø³Ø© Ø¨Ù†Ø¬Ø§Ø­',
        });
      } catch (error) {
        logger.error('Failed to delete session', {
          sessionId: id,
          error: error instanceof Error ? error.message : String(error),
        });

        return reply.status(500).send({
          error: 'Failed to delete session',
        });
      }
    }
  );
}

#####
Ø£ØªØ§Ø¨Ø¹ ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© Ù…Ø¹ Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù€ Routes ÙˆØ§Ù„Ù€ Middlewares...
########